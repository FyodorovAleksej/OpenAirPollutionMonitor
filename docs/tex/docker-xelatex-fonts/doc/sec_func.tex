\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:func}

Рассмотрим подробно функционирование программы.
Для этого проведем анализ основных модулей программы и рассмотрим их зависимости.
А также проанализируем все модули, которые входят в состав кода программы, и рассмотрим назначение всех методов и переменных этих модулей.
В разрабатываемом приложении можно выделить следующие модули:
\begin{itemize}
    \item модуль конфигурации загрузчика;
    \item модуль хранения загрузчика;
    \item модуль внешнего подключения загрузчика;
    \item модуль обработки загрузчика;
    \item модуль отправки загрузчика;
    \item модуль приёма обработчика;
    \item модуль анализа обработчика;
    \item модуль сохранения обработчика;
    \item модуль визуализации обработчика.
\end{itemize}

Изначально пользователю предоставляется интерактивный документ на Apache Zepelin, в котором он может просмотреть обработанные данные.

\subsection{Классы модуля конфигурации загрузчика}
Для конфигурации приложения используются файлы конфигурации.
Классы данного модуля как раз представляют объекты конфигураций, которые создаются на основе файлов конфигураций.
Главным объектом конфигурации является класс \texttt{ApplicationConfig}.
Он содержит в себе все остальные конфигурации, необходимые для работы всего приложения.
Сам объект этого класса строится с помощью метода \texttt{parse\_from\_file()}.
Этот класс включает в себя более специфические конфигурации, представленные классами: \texttt{APIConfig}, \texttt{FSConfig}, \texttt{KafkaProducerConfig}.

\subsubsection{Класс \texttt{APIConfig}}

Данный класс представляет из себя конфигурацию для работы с сервисом OpenWeatherMap.
Сам объект класса создаётся из списка строк, которые представляют собой строки файла конфигурации, ответственные за настройку API.
Конфигурация содержит в себе следующие поля:
\begin{itemize}
    \item \texttt{api\_key};
    \item \texttt{host}.
\end{itemize}

Для использования сервиса OpenWeatherMap необходимо предоставить ключ, который выдаётся при оформлении подписки на определённый сервис API.
Данный параметр как раз и является этим ключом.
Этот ключ передаётся в качестве параметра при использовании GET запроса к сервису.
Как раз для этого ключа и используется параметр \texttt{api\_key} в конфигурации.

Параметр \texttt{host} устанавливает корневой путь к сервису OpenWeatherMap.
Относительно этого пути и строятся все HTTP запросы для получения данных.

Для создания экземпляра рассматриваемого класса, необходимо вызвать статический метод \texttt{parse\_from\_lines()}, который принимает список строк, из которых и будет строиться конфигурация.
Для получения ключа для использования API и адреса сервиса OpenWeatherMap из конфигурации, необходимо воспользоваться методами \texttt{get\_api\_key()} и \texttt{get\_host()} соответственно.

\subsubsection{Класс \texttt{FSConfig}}

Так как для всего приложения используется полноценный кластер, то и необходима возможность использования приложения в экосистеме Hadoop.
В этой экосистеме используется HDFS, как уже неоднократно отмечалось.
Если для работы с локальной файловой системой можно обойтись без каких-либо конфигураций, то для HDFS необходимо знать её корневой адрес.
Данный адрес и является полем \texttt{host} в рассматриваемой конфигурации и задаётся с помощью файлов конфигурации.

Для создания экземпляра этого класса, необходимо вызвать статический метод \texttt{parse\_from\_lines()}, который принимает список строк, из которых и будет строиться конфигурация.
Для получения адреса к корневому каталогу в используемой локальной системе из конфигурации, необходимо воспользоваться методами \texttt{get\_host()}.

Для обработки записей из файла конфигурации вызывается статический метод \texttt{prepare}.
Данный метод обрезает пробельные символы.
Это необходимо для гарантии уникальности ключа.

\subsubsection{Класс \texttt{KafkaProducerConfig}}

Данный класс представляет из себя конфигурацию для работы с платформой kafka.
Сам объект класса создаётся из списка строк, которые представляют собой строки файла конфигурации, ответственные за настройку kafka producer.
Конфигурация содержит в себе следующие поля:
\begin{itemize}
    \item \texttt{bootstrap\_servers};
    \item \texttt{client\_id};
    \item \texttt{key\_serializer};
    \item \texttt{value\_serializer};
    \item \texttt{acks};
    \item \texttt{compression\_type};
    \item \texttt{retries};
    \item \texttt{batch\_size};
    \item \texttt{max\_request\_size};
    \item \texttt{request\_timeout\_ms};
    \item \texttt{security\_protocol}.
\end{itemize}

Параметр \texttt{bootstrap\_servers} указывает адреса kafka серверов в формате <<host[:port]>>.

Параметр \texttt{client\_id} указывает уникальный идентификатор клиента.
Данный идентификатор используется для логирования.

Параметр \texttt{key\_serializer} указывает имя класса сериализатора для ключа.
Данный параметр необходим для возможности передачи пользовательских объектов в качестве ключа.

Аналогичным является параметр \texttt{value\_serializer}, который указывает имя класса сериализатора для значения.
Этот параметр необходим для возможности передачи пользовательских объектов в качестве значения.
Также kafka предоставляет набор стандартных классов для сериализации и десериализации.
Например \texttt{org.apache.kafka.common.serialization.StringSerializer} и \texttt{org.apache.kafka.common.serialization.StringDeserializer}.

Параметр \texttt{acks} указывает требуемое количество подтверждений от kafka серверов.
Возможные значения:
\begin{itemize}
    \item \texttt{0}. Означает, что подтверждения не требуются;
    \item \texttt{1}. Используется по умолчанию. Означает, что требуется хотя бы одно подтверждение;
    \item \texttt{all}. Означает, что для каждого запроса необходимо подтверждение.
\end{itemize}

Параметр \texttt{compression\_type} указывает тип сжатия для всех отправленных данных, либо его отсутствие.
Возможные значения:
\begin{itemize}
    \item \texttt{gzip};
    \item \texttt{snappy};
    \item \texttt{lz4};
    \item \texttt{None}. Используется по умолчанию.
\end{itemize}

Параметр \texttt{retries} указывает количество попыток отправить данные заново при неудаче.

Параметр \texttt{batch\_size} указывает максимальный размер пакета для отправки.
При превышении данного размера, данные будут разбиты на несколько пакетов.

Параметр \texttt{max\_request\_size} указывает максимальный размер запроса.

Параметр \texttt{request\_timeout\_ms} указывает максимальное время ожидания ответа при отправке пакета в миллисекундах.
При превышении данного времени - считается, что пакет не был доставлен.

Параметр \texttt{security\_protocol} указывает используемый протокол для связи с серверами kafka.
Возможные значения:
\begin{itemize}
    \item \texttt{PLAINTEXT}. Используется по умолчанию;
    \item \texttt{SSL};
    \item \texttt{SASL\_PLAINTEXT};
    \item \texttt{SASL\_SSL}.
\end{itemize}

Для того, чтобы создать экземпляр класса, следует использовать статический метод \texttt{parse\_from\_lines()}, который принимает список строк с конфигурацией kafka producer из файлов конфигурации.

Для обработки записей из файла конфигурации вызывается статический метод \texttt{prepare}.
Данный метод обрезает пробельные символы.
Это необходимо для гарантии уникальности ключа.

\subsubsection{Класс \texttt{KafkaConsumerConfig}}

Данный класс представляет из себя конфигурацию для работы с платформой kafka.
Сам объект класса создаётся из списка строк, которые представляют собой строки файла конфигурации, ответственные за настройку kafka consumer.
Конфигурация содержит в себе следующие поля:
\begin{itemize}
    \item \texttt{bootstrap\_servers};
    \item \texttt{client\_id};
    \item \texttt{group\_id};
    \item \texttt{key\_deserializer};
    \item \texttt{value\_deserializer};
    \item \texttt{auto\_offset\_reset};
    \item \texttt{enable\_auto\_commit};
    \item \texttt{auto\_commit\_interval\_ms};
    \item \texttt{session\_timeout\_ms};
    \item \texttt{security\_protocol}.
\end{itemize}

Параметр \texttt{bootstrap\_servers} указывает адреса kafka серверов в формате <<host[:port]>>.

Параметр \texttt{client\_id} указывает уникальный идентификатор клиента.
Данный идентификатор используется для логирования.

Параметр \texttt{group\_id} указывает уникальный идентификатор группы получателей.
Получатели с одинаковым идентификатором группы будут иметь одинаковое смещение, что позволит считывать одинаковые данные для всех получателей в группе.

Параметр \texttt{key\_deserializer} указывает имя класса десериализатора для ключа.
Данный параметр необходим для возможности передачи пользовательских объектов в качестве ключа.

Аналогичным является параметр \texttt{value\_deserializer}, который указывает имя класса десериализатора для значения.
Этот параметр необходим для возможности передачи пользовательских объектов в качестве значения.
Также kafka предоставляет набор стандартных классов для сериализации и десериализации.
Например \texttt{org.apache.kafka.common.serialization.StringSerializer} и \texttt{org.apache.kafka.common.serialization.StringDeserializer}.

Параметр \texttt{auto\_offset\_reset} указывает правила для сброса смещения для получателя при переподключении.
Может принимать следующие значения:
\begin{itemize}
    \item \texttt{earliest}. При переподключении данные будут браться с самого начала раздела;
    \item \texttt{latest}. Используется по умолчанию. При переподключении данные будут браться с последнего сохранённого смещения.   
\end{itemize}

Параметр \texttt{enable\_auto\_commit} указывает на возможность использования автоматического сохранения используемого смещения.
Если данный параметр включен, то будет происходить автоматическое сохранение текущего смещения в разделе с определённным интервалом.
По умолчанию включен.

Параметр \texttt{auto\_commit\_interval\_ms} указывает интервал в миллисекундах, с которым будет происходить сохранение текущего смещения в разделе.
По умолчанию установлен в 5000 миллисекунд.

Параметр \texttt{session\_timeout\_ms} указывает максимальное время ожидания специального сигнала, который отсылается бокером получателю.
При превышении данного времени - считается, что брокер не доступен.
По умолчанию установлен в 10000 миллисекунд.

Параметр \texttt{security\_protocol} указывает используемый протокол для связи с серверами kafka.
Возможные значения:
\begin{itemize}
    \item \texttt{PLAINTEXT}. Используется по умолчанию;
    \item \texttt{SSL};
    \item \texttt{SASL\_PLAINTEXT};
    \item \texttt{SASL\_SSL}.
\end{itemize}

Для того, чтобы создать экземпляр класса, следует использовать статический метод \texttt{parse\_from\_lines()}, который принимает список строк с конфигурацией kafka consumer из файлов конфигурации.

Для обработки записей из файла конфигурации вызывается статический метод \texttt{prepare}.
Данный метод обрезает пробельные символы.
Это необходимо для гарантии уникальности ключа.

\subsection{Классы модуля хранения загрузчика}
Для сохранения данных может использоваться как локальная файловая система, так и распределённая (HDFS).
Для обеспечения работы с файловой системой, необходимо реализовать базовые операции, которые указаны в интерфейсе \texttt{FileSystemAdapter}.
Его реализация \texttt{DefaultFileSystem} предназначена для произведения операций с помощью локальной файловой системы.
А реализация \texttt{DistributedFileSystem} предназначена для произведения операция с помощью распределённой файловой системы (HDFS).

\subsubsection{Интерфейс \texttt{FileSystemAdapter}}
Предназначен для осуществления операций с файловой системой.
Содержит следующие методы:
\begin{itemize}
    \item \texttt{write\_file()};
    \item \texttt{append\_to\_file()};
    \item \texttt{read\_file()};
    \item \texttt{remove\_file()};
    \item \texttt{mkdir()};
    \item \texttt{ls()};
    \item \texttt{is\_exist()};
    \item \texttt{to\_file\_path()}.
\end{itemize}

Метод \texttt{write\_file()} принимает относительный путь в файловой системе и массив байтов.
Предназначен для записи переданных байтов в файл.
Если переданный файл не существует, то он создаётся.
Если переданный файл уже существует, то он будет перезаписан.
В результате ничего не возвращает.

Метод \texttt{append\_to\_file()} принимает относительный путь в файловой системе и массив байтов.
Предназначен для добавления байтов в файл.
Если переданный файл не существует, то он будет создан
В результате ничего не возвращает.

Метод \texttt{read\_file()} принимает относительный путь в файловой системе.
Предназначен для чтения байтов из файла.
Если файл не существует, то возвращает \texttt{null}.
В результате возвращает массив считанных байт из файла.

Метод \texttt{remove\_file()} принимает относительный путь в файловой системе.
Предназначен для удаления файла.
В результате возвращает \texttt{true} в случае успеха и \texttt{false} если файл не существовал.

Метод \texttt{mkdir()} принимает относительный путь в файловой системе.
Предназначен для создания директории. 
В результате ничего не возвращает.

Метод \texttt{ls()} принимает относительный путь в файловой системе.
Предназначен для получения всех существующих файлов в директории.
В результате возвращает список файлов, которые находятся в переданной директории.
В случае, если такой директории не существует, то возвращает \texttt{null}.

Метод \texttt{is\_exist()} принимает относительный путь в файловой системе.
Предназначен для проверки существования пути в файловой системе.
В результате возвращает \texttt{true}, если путь существует и \texttt{false}, если путь не существует.

Метод \texttt{to\_file\_path()} принимает относительный путь в файловой системе к директории, географическую широту, географическую долготу, год.
Предназначен для получения пути к файлу, который содержит результат запроса с переданными параметрами.
В результате возвращает путь к файлу.


\subsubsection{Класс \texttt{DefaultFileSystem}}
Предназначен для осуществления операций с локальной файловой системой.
Имплементирует следующие методы:
\begin{itemize}
    \item \texttt{write\_file()};
    \item \texttt{append\_to\_file()};
    \item \texttt{read\_file()};
    \item \texttt{remove\_file()};
    \item \texttt{mkdir()};
    \item \texttt{ls()};
    \item \texttt{is\_exist()};
    \item \texttt{to\_file\_path()}.
\end{itemize}

Метод \texttt{write\_file()} принимает относительный путь в локальной файловой системе и массив байтов.
Предназначен для записи переданных байтов в файл.
Если переданный файл не существует, то он создаётся.
Если переданный файл уже существует, то он будет перезаписан.
В результате ничего не возвращает.

Метод \texttt{append\_to\_file()} принимает относительный путь в локальной файловой системе и массив байтов.
Предназначен для добавления байтов в файл.
Если переданный файл не существует, то он будет создан
В результате ничего не возвращает.

Метод \texttt{read\_file()} принимает относительный путь в локальной файловой системе.
Предназначен для чтения байтов из файла.
Если файл не существует, то возвращает \texttt{null}.
В результате возвращает массив считанных байт из файла.

Метод \texttt{remove\_file()} принимает относительный путь в локальной файловой системе.
Предназначен для удаления файла.
В результате возвращает \texttt{true} в случае успеха и \texttt{false} если файл не существовал.

Метод \texttt{mkdir()} принимает относительный путь в локальной файловой системе.
Предназначен для создания директории. 
В результате ничего не возвращает.

Метод \texttt{ls()} принимает относительный путь в локальной файловой системе.
Предназначен для получения всех существующих файлов в директории.
В результате возвращает список файлов, которые находятся в переданной директории.
В случае, если такой директории не существует, то возвращает \texttt{null}.

Метод \texttt{is\_exist()} принимает относительный путь в локальной файловой системе.
Предназначен для проверки существования пути в локальной файловой системе.
В результате возвращает \texttt{true}, если путь существует и \texttt{false}, если путь не существует.

Метод \texttt{to\_file\_path()} принимает относительный путь в локальной файловой системе к директории, географическую широту, географическую долготу, год.
Предназначен для получения пути к файлу, который содержит результат запроса с переданными параметрами.
В результате возвращает путь к файлу.


\subsubsection{Класс \texttt{DistributedFileSystem}}
Предназначен для осуществления операций с распределённой файловой системой (HDFS).
Имплементирует следующие методы:
\begin{itemize}
    \item \texttt{write\_file()};
    \item \texttt{append\_to\_file()};
    \item \texttt{read\_file()};
    \item \texttt{remove\_file()};
    \item \texttt{mkdir()};
    \item \texttt{ls()};
    \item \texttt{is\_exist()};
    \item \texttt{to\_file\_path()}.
\end{itemize}

Метод \texttt{write\_file()} принимает относительный путь в распределённой файловой системе (HDFS) и массив байтов.
Предназначен для записи переданных байтов в файл.
Если переданный файл не существует, то он создаётся.
Если переданный файл уже существует, то он будет перезаписан.
В результате ничего не возвращает.

Метод \texttt{append\_to\_file()} принимает относительный путь в распределённой файловой системе (HDFS) и массив байтов.
Предназначен для добавления байтов в файл.
Если переданный файл не существует, то он будет создан
В результате ничего не возвращает.

Метод \texttt{read\_file()} принимает относительный путь в распределённой файловой системе (HDFS).
Предназначен для чтения байтов из файла.
Если файл не существует, то возвращает \texttt{null}.
В результате возвращает массив считанных байт из файла.

Метод \texttt{remove\_file()} принимает относительный путь в распределённой файловой системе (HDFS).
Предназначен для удаления файла.
В результате возвращает \texttt{true} в случае успеха и \texttt{false} если файл не существовал.

Метод \texttt{mkdir()} принимает относительный путь в распределённой файловой системе (HDFS).
Предназначен для создания директории. 
В результате ничего не возвращает.

Метод \texttt{ls()} принимает относительный путь в распределённой файловой системе (HDFS).
Предназначен для получения всех существующих файлов в директории.
В результате возвращает список файлов, которые находятся в переданной директории.
В случае, если такой директории не существует, то возвращает \texttt{null}.

Метод \texttt{is\_exist()} принимает относительный путь в распределённой файловой системе (HDFS).
Предназначен для проверки существования пути в распределённой файловой системе.
В результате возвращает \texttt{true}, если путь существует и \texttt{false}, если путь не существует.

Метод \texttt{to\_file\_path()} принимает относительный путь в распределённой файловой системе к директории, географическую широту, географическую долготу, год.
Предназначен для получения пути к файлу, который содержит результат запроса с переданными параметрами.
В результате возвращает путь к файлу.


В качестве аргумента в конструкторе принимает экземпляр класса \texttt{FSConfig}, в котором располагаются необходимые параметры для работы с файловой системой.
Корневая директория, в которой будут располагаться все файлы проекта, получается из конфигурации с помощью метода \texttt{get\_dir}.
Адрес хоста получается из конфигурации с помощью метода \texttt{get\_host()}.

\subsection{Классы модуля конфигурации загрузчика}
Для получения данных из сервиса OpenWeatherMap необходимо использовать HTTP запросы.
Структура запросов различаются для каждого типа API, которые используются для получения разных индексов загрязнения.


\subsubsection{Класс \texttt{PollutionDumper}}
Данный класс используется для получения данных из внешнего сервиса OpenWeatherMap.
Для подключения к нему, необходимы следующие параметры:

\begin{itemize}
\item \texttt{api\_key}. Ключ для получения доступа к api сервиса;
\item \texttt{host}. Адрес самого сервиса.
\end{itemize}

Все эти параметры хранятся в файлах конфигурации приложения.
После загрузки конфигурации, создаётся экземпляр класса \texttt{APIConfig}, который как раз и содержит необходимые для доступа параметры.
При помощи методов \texttt{get\_api\_key()} и \texttt{get\_host()} этого класса возможно получить необходимые параметры: ключ для api и адрес используемого сервиса соответственно.
Экземпляр данного класса используется в конструкторе класса \texttt{PollutionDumper}.

Также для пропуска уже полученных данных, необходим инструмент работы с файловой системой.
В качестве данного инструмента, подойдёт интерфейс \texttt{FileSystemAdapter}.
В зависимости от конфигурации, мы сможем работать либо с локальной файловой системой с помощью экземпляра класса \texttt{DefaultFileSystem}, либо с распределённой файловой системой (HDFS) при помощи экземпляра класса \texttt{DistributedFileSystem}.
Благодаря данному объекту, мы сможем использовать один и тот же интерфейс, не завися от того, как развёрнуто приложение - в локальном режиме или с использованием кластера Hadoop.

Рассматриваемый класс имеет следующие методы:
\begin{itemize}
\item \texttt{dump()};
\item \texttt{to\_address()}.
\end{itemize}

Метод \texttt{dump()} принимает географическую широту, географическую долготу и год.
Сначала метод с помощью используемого адаптера файловой системы ищет в ней файл, в котором находятся данные с переданными параметрами.
В случае, если такой файл существует, то возвращает данные из этого файла.
Если такой файл не был найден, то происходит обращение к внешнему сервису OpenWeatherMap для получения данных по переданным географическим координатам и переданному году.
Для их получения составляется HTTP запрос с переданными аргументами и отправляется на сервер.
В случае, если такие данные есть на сервере, то полученные данные будут записаны в соответствующий файл в используемой файловой системе.
Если же таких данных нет и сервер вернул ошибку, то будет выброшено исключение, которое далее будет залогировано вызываемым классом.
Возвращает найденные или полученные с сервиса данные.

Метод \texttt{to\_address()} принимает географическую широту, географическую долготу и год.
Формирует адрес HTTP запроса для получения данных по конкретному индексу.
Так как адреса запросов разные у каждого индекса, то данный метод будет переопределяться у каждого конкретного дочернего класса.
Возвращает адрес для HTTP запроса.



\subsubsection{Класс \texttt{NODumper}}
Данный класс используется для получения индекса загрязнения диоксидом азота ($ \text{NO}_{\text{2}} $) из внешнего сервиса OpenWeatherMap.
Для подключения к нему, необходимы следующие параметры:

\begin{itemize}
\item \texttt{api\_key}. Ключ для получения доступа к api сервиса;
\item \texttt{host}. Адрес самого сервиса.
\end{itemize}

Все эти параметры хранятся в файлах конфигурации приложения.
После загрузки конфигурации, создаётся экземпляр класса \texttt{APIConfig}, который как раз и содержит необходимые для доступа параметры.
При помощи методов \texttt{get\_api\_key()} и \texttt{get\_host()} этого класса возможно получить необходимые параметры: ключ для api и адрес используемого сервиса соответственно.
Экземпляр данного класса используется в конструкторе родительского класса \texttt{PollutionDumper}.

Также для пропуска уже полученных данных, необходим инструмент работы с файловой системой.
В качестве данного инструмента, подойдёт интерфейс \texttt{FileSystemAdapter}.
В зависимости от конфигурации, мы сможем работать либо с локальной файловой системой с помощью экземпляра класса \texttt{DefaultFileSystem}, либо с распределённой файловой системой (HDFS) при помощи экземпляра класса \texttt{DistributedFileSystem}.
Благодаря данному объекту, мы сможем использовать один и тот же интерфейс, не завися от того, как развёрнуто приложение - в локальном режиме или с использованием кластера Hadoop.

Рассматриваемый класс имеет следующие методы:
\begin{itemize}
\item \texttt{dump()};
\item \texttt{to\_address()}.
\end{itemize}

Метод \texttt{dump()} принимает географическую широту, географическую долготу и год.
Сначала метод с помощью используемого адаптера файловой системы ищет в ней файл, в котором находятся данные с переданными параметрами.
В случае, если такой файл существует, то возвращает данные из этого файла.
Если такой файл не был найден, то происходит обращение к внешнему сервису OpenWeatherMap для получения данных по переданным географическим координатам и переданному году.
Для их получения составляется HTTP запрос с переданными аргументами и отправляется на сервер.
В случае, если такие данные есть на сервере, то полученные данные будут записаны в соответствующий файл в используемой файловой системе.
Если же таких данных нет и сервер вернул ошибку, то будет выброшено исключение, которое далее будет залогировано вызываемым классом.
Возвращает найденный или полученный с сервиса индекс загрязнения диоксидом азота.

Метод \texttt{to\_address()} принимает географическую широту, географическую долготу и год.
Формирует адрес HTTP запроса для получения индекса загрязнения диоксидом азота.
Возвращает адрес для HTTP запроса.




\subsubsection{Класс \texttt{SODumper}}
Данный класс используется для получения индекса загрязнения диоксидом серы ($ \text{SO}_{\text{2}} $) из внешнего сервиса OpenWeatherMap.
Для подключения к нему, необходимы следующие параметры:

\begin{itemize}
\item \texttt{api\_key}. Ключ для получения доступа к api сервиса;
\item \texttt{host}. Адрес самого сервиса.
\end{itemize}

Все эти параметры хранятся в файлах конфигурации приложения.
После загрузки конфигурации, создаётся экземпляр класса \texttt{APIConfig}, который как раз и содержит необходимые для доступа параметры.
При помощи методов \texttt{get\_api\_key()} и \texttt{get\_host()} этого класса возможно получить необходимые параметры: ключ для api и адрес используемого сервиса соответственно.
Экземпляр данного класса используется в конструкторе родительского класса \texttt{PollutionDumper}.

Также для пропуска уже полученных данных, необходим инструмент работы с файловой системой.
В качестве данного инструмента, подойдёт интерфейс \texttt{FileSystemAdapter}.
В зависимости от конфигурации, мы сможем работать либо с локальной файловой системой с помощью экземпляра класса \texttt{DefaultFileSystem}, либо с распределённой файловой системой (HDFS) при помощи экземпляра класса \texttt{DistributedFileSystem}.
Благодаря данному объекту, мы сможем использовать один и тот же интерфейс, не завися от того, как развёрнуто приложение - в локальном режиме или с использованием кластера Hadoop.

Рассматриваемый класс имеет следующие методы:
\begin{itemize}
\item \texttt{dump()};
\item \texttt{to\_address()}.
\end{itemize}

Метод \texttt{dump()} принимает географическую широту, географическую долготу и год.
Сначала метод с помощью используемого адаптера файловой системы ищет в ней файл, в котором находятся данные с переданными параметрами.
В случае, если такой файл существует, то возвращает данные из этого файла.
Если такой файл не был найден, то происходит обращение к внешнему сервису OpenWeatherMap для получения данных по переданным географическим координатам и переданному году.
Для их получения составляется HTTP запрос с переданными аргументами и отправляется на сервер.
В случае, если такие данные есть на сервере, то полученные данные будут записаны в соответствующий файл в используемой файловой системе.
Если же таких данных нет и сервер вернул ошибку, то будет выброшено исключение, которое далее будет залогировано вызываемым классом.
Возвращает найденный или полученный с сервиса индекс загрязнения диоксидом серы.

Метод \texttt{to\_address()} принимает географическую широту, географическую долготу и год.
Формирует адрес HTTP запроса для получения индекса загрязнения диоксидом серы.
Возвращает адрес для HTTP запроса.



\subsubsection{Класс \texttt{OZDumper}}
Данный класс используется для получения индекса загрязнения озоном ($ \text{O}_{\text{3}} $) из внешнего сервиса OpenWeatherMap.
Для подключения к нему, необходимы следующие параметры:

\begin{itemize}
\item \texttt{api\_key}. Ключ для получения доступа к api сервиса;
\item \texttt{host}. Адрес самого сервиса.
\end{itemize}

Все эти параметры хранятся в файлах конфигурации приложения.
После загрузки конфигурации, создаётся экземпляр класса \texttt{APIConfig}, который как раз и содержит необходимые для доступа параметры.
При помощи методов \texttt{get\_api\_key()} и \texttt{get\_host()} этого класса возможно получить необходимые параметры: ключ для api и адрес используемого сервиса соответственно.
Экземпляр данного класса используется в конструкторе родительского класса \texttt{PollutionDumper}.

Также для пропуска уже полученных данных, необходим инструмент работы с файловой системой.
В качестве данного инструмента, подойдёт интерфейс \texttt{FileSystemAdapter}.
В зависимости от конфигурации, мы сможем работать либо с локальной файловой системой с помощью экземпляра класса \texttt{DefaultFileSystem}, либо с распределённой файловой системой (HDFS) при помощи экземпляра класса \texttt{DistributedFileSystem}.
Благодаря данному объекту, мы сможем использовать один и тот же интерфейс, не завися от того, как развёрнуто приложение - в локальном режиме или с использованием кластера Hadoop.

Рассматриваемый класс имеет следующие методы:
\begin{itemize}
\item \texttt{dump()};
\item \texttt{to\_address()}.
\end{itemize}

Метод \texttt{dump()} принимает географическую широту, географическую долготу и год.
Сначала метод с помощью используемого адаптера файловой системы ищет в ней файл, в котором находятся данные с переданными параметрами.
В случае, если такой файл существует, то возвращает данные из этого файла.
Если такой файл не был найден, то происходит обращение к внешнему сервису OpenWeatherMap для получения данных по переданным географическим координатам и переданному году.
Для их получения составляется HTTP запрос с переданными аргументами и отправляется на сервер.
В случае, если такие данные есть на сервере, то полученные данные будут записаны в соответствующий файл в используемой файловой системе.
Если же таких данных нет и сервер вернул ошибку, то будет выброшено исключение, которое далее будет залогировано вызываемым классом.
Возвращает найденный или полученный с сервиса индекс загрязнения озоном.

Метод \texttt{to\_address()} принимает географическую широту, географическую долготу и год.
Формирует адрес HTTP запроса для получения индекса загрязнения озоном.
Возвращает адрес для HTTP запроса.



\subsubsection{Класс \texttt{CODumper}}
Данный класс используется для получения индекса загрязнения монооксидом углерода ($ \text{CO} $) из внешнего сервиса OpenWeatherMap.
Для подключения к нему, необходимы следующие параметры:

\begin{itemize}
\item \texttt{api\_key}. Ключ для получения доступа к api сервиса;
\item \texttt{host}. Адрес самого сервиса.
\end{itemize}

Все эти параметры хранятся в файлах конфигурации приложения.
После загрузки конфигурации, создаётся экземпляр класса \texttt{APIConfig}, который как раз и содержит необходимые для доступа параметры.
При помощи методов \texttt{get\_api\_key()} и \texttt{get\_host()} этого класса возможно получить необходимые параметры: ключ для api и адрес используемого сервиса соответственно.
Экземпляр данного класса используется в конструкторе родительского класса \texttt{PollutionDumper}.

Также для пропуска уже полученных данных, необходим инструмент работы с файловой системой.
В качестве данного инструмента, подойдёт интерфейс \texttt{FileSystemAdapter}.
В зависимости от конфигурации, мы сможем работать либо с локальной файловой системой с помощью экземпляра класса \texttt{DefaultFileSystem}, либо с распределённой файловой системой (HDFS) при помощи экземпляра класса \texttt{DistributedFileSystem}.
Благодаря данному объекту, мы сможем использовать один и тот же интерфейс, не завися от того, как развёрнуто приложение - в локальном режиме или с использованием кластера Hadoop.

Рассматриваемый класс имеет следующие методы:
\begin{itemize}
\item \texttt{dump()};
\item \texttt{to\_address()}.
\end{itemize}

Метод \texttt{dump()} принимает географическую широту, географическую долготу и год.
Сначала метод с помощью используемого адаптера файловой системы ищет в ней файл, в котором находятся данные с переданными параметрами.
В случае, если такой файл существует, то возвращает данные из этого файла.
Если такой файл не был найден, то происходит обращение к внешнему сервису OpenWeatherMap для получения данных по переданным географическим координатам и переданному году.
Для их получения составляется HTTP запрос с переданными аргументами и отправляется на сервер.
В случае, если такие данные есть на сервере, то полученные данные будут записаны в соответствующий файл в используемой файловой системе.
Если же таких данных нет и сервер вернул ошибку, то будет выброшено исключение, которое далее будет залогировано вызываемым классом.
Возвращает найденный или полученный с сервиса индекс загрязнения монооксидом углерода.

Метод \texttt{to\_address()} принимает географическую широту, географическую долготу и год.
Формирует адрес HTTP запроса для получения индекса загрязнения монооксидом углерода.
Возвращает адрес для HTTP запроса.




\subsection{Классы модуля обработки загрузчика}
От сервера приходят данные в формате JavaScript Object Notation (JSON).
Такие данные не подвергаются анализу, поэтому их необходимо обработать и получить значения, которые могут быть использованы в последующих операциях.
Для обработки полученных данных как раз и используются рассматриваемые ниже классы.

\subsubsection{Класс \texttt{DumpParser}}
Данный класс используется для обработки данных, полученных от сервера OpenWeatherMap.
Так как каждый API предоставляет данные в своём формате, то и для каждого API необходим свой обработчик.
Обработчиками являются экземпляры класса \texttt{JsonParser}.
При создании экземпляра данного класса, в конструктор передаются экземпляры, имплементирующие интерфейс \texttt{JsonParser}.
Так как для каждого API устанавливается свой обработчик, то и поля соответсвуют используемым API:
\begin{itemize}
    \item \texttt{co\_parser}. Соответсвует обработчику полученных данных об индексе загрязнения монооксидом углерода ($ \text{CO} $);
    \item \texttt{so\_parser}. Соответсвует обработчику полученных данных об индексе загрязнения диоксидом серы ($ \text{SO}_{\text{2}} $);
    \item \texttt{oz\_parser}. Соответсвует обработчику полученных данных об индексе загрязнения озоном ($ \text{O}_{\text{3}} $);
    \item \texttt{no\_parser}. Соответсвует обработчику полученных данных об индексе загрязнения диоксидом азота ($ \text{NO}_{\text{2}} $).
\end{itemize}

Метод \texttt{parse\_co()} используется для преобразования полученных данных по API, предоставляющего данные о индексе загрязнения монооксидом углерода ($ \text{CO} $) в формате JSON.
Принимает данные в формате JSON.
Возвращает список значений с критериями, которые были указаны в используемом обработчике данных для моонооксида углерода ($ \text{CO} $).


Метод \texttt{parse\_so()} используется для преобразования полученных данных по API, предоставляющего данные о индексе загрязнения диоксидом серы ($ \text{SO}_{\text{2}} $) в формате JSON.
Принимает данные в формате JSON.
Возвращает список значений с критериями, которые были указаны в используемом обработчике данных для диоксида серы ($ \text{SO}_{\text{2}} $).


Метод \texttt{parse\_oz()} используется для преобразования полученных данных по API, предоставляющего данные о индексе загрязнения озоном ($ \text{O}_{\text{3}} $) в формате JSON.
Принимает данные в формате JSON.
Возвращает список значений с критериями, которые были указаны в используемом обработчике данных для озона ($ \text{O}_{\text{3}} $).


Метод \texttt{parse\_no()} используется для преобразования полученных данных по API, предоставляющего данные о индексе загрязнения диоксидом азота ($ \text{NO}_{\text{2}} $) в формате JSON.
Принимает данные в формате JSON.
Возвращает список значений с критериями, которые были указаны в используемом обработчике данных для диоксида азота ($ \text{NO}_{\text{2}} $).


\subsubsection{Интерфейс \texttt{JsonParser}}
Для обработки данных в формате JSON используется отдельный интерфейс \texttt{JsonParser}.
Так как структура предоставляемых данных может измениться в будущем, то необходимо предоставить возможность заменить используемые обработчики на другие, для поддержания нового формата данных.
Благодаря такому подходу, можно использовать различные источники данных.
Сам интерфейс содержит только один метод \texttt{parse()}.

Метод \texttt{parse()} используется для преобразования полученных данных в значения, которые можно проанализировать.
На вход принимает данные в формает JSON.
Возвращает список полученных значений.


\subsubsection{Класс \texttt{NOParser}}
Рассматриваемый класс используется для обработки данных об индексе загрязнения диоксидом азота в формате JSON.
Так как структура предоставляемых данных может измениться в будущем, то необходимо предоставить возможность заменить данный обработчик на другой, для поддержания нового формата данных.
Благодаря такому подходу, можно использовать различные источники данных.

Так как используемый формат предоставляет множество значений для разного давления, то необходимо ограничить значения давления, для которого и будут отбираться данные.
Для этих целей используются поля, которые передаются в конструктор:
\begin{itemize}
    \item \texttt{min\_pressure};
    \item \texttt{max\_pressure}.
\end{itemize}

Поле \texttt{min\_pressure} задаёт минимальную границу давления, для которого будут отобраны значения.
Поле \texttt{max\_pressure} задаёт максимальную границу давления, для которого будут отобраны значения.
Оба этих параметра передаются в контруктор класса \texttt{NOParser}.

Метод \texttt{parse()} используется для преобразования полученных данных в значения, которые можно проанализировать.
На вход принимает данные об индексе загрязнения диоксидом азота в формате JSON.
Возвращает список полученных значений индекса загрязнения диоксидом азота.





\subsubsection{Класс \texttt{SOParser}}
Рассматриваемый класс используется для обработки данных об индексе загрязнения диоксидом серы в формате JSON.
Так как структура предоставляемых данных может измениться в будущем, то необходимо предоставить возможность заменить данный обработчик на другой, для поддержания нового формата данных.
Благодаря такому подходу, можно использовать различные источники данных.

Так как используемый формат предоставляет множество значений для разного давления, то необходимо ограничить значения давления, для которого и будут отбираться данные.
Для этих целей используются поля, которые передаются в конструктор:
\begin{itemize}
    \item \texttt{min\_pressure};
    \item \texttt{max\_pressure}.
\end{itemize}

Поле \texttt{min\_pressure} задаёт минимальную границу давления, для которого будут отобраны значения.
Поле \texttt{max\_pressure} задаёт максимальную границу давления, для которого будут отобраны значения.
Оба этих параметра передаются в контруктор класса \texttt{SOParser}.

Метод \texttt{parse()} используется для преобразования полученных данных в значения, которые можно проанализировать.
На вход принимает данные об индексе загрязнения диоксидом серы в формате JSON.
Возвращает список полученных значений индекса загрязнения диоксидом серы.


\subsubsection{Класс \texttt{OZParser}}
Рассматриваемый класс используется для обработки данных об индексе загрязнения озоном в формате JSON.
Так как структура предоставляемых данных может измениться в будущем, то необходимо предоставить возможность заменить данный обработчик на другой, для поддержания нового формата данных.
Благодаря такому подходу, можно использовать различные источники данных.

Так как используемый формат предоставляет множество значений для разного давления, то необходимо ограничить значения давления, для которого и будут отбираться данные.
Для этих целей используются поля, которые передаются в конструктор:
\begin{itemize}
    \item \texttt{min\_pressure};
    \item \texttt{max\_pressure}.
\end{itemize}

Поле \texttt{min\_pressure} задаёт минимальную границу давления, для которого будут отобраны значения.
Поле \texttt{max\_pressure} задаёт максимальную границу давления, для которого будут отобраны значения.
Оба этих параметра передаются в контруктор класса \texttt{OZParser}.

Метод \texttt{parse()} используется для преобразования полученных данных в значения, которые можно проанализировать.
На вход принимает данные об индексе загрязнения озоном в формате JSON.
Возвращает список полученных значений индекса загрязнения озоном.


\subsubsection{Класс \texttt{COParser}}
Рассматриваемый класс используется для обработки данных об индексе загрязнения диоксидом углерода в формате JSON.
Так как структура предоставляемых данных может измениться в будущем, то необходимо предоставить возможность заменить данный обработчик на другой, для поддержания нового формата данных.
Благодаря такому подходу, можно использовать различные источники данных.

Так как используемый формат предоставляет множество значений для разного давления, то необходимо ограничить значения давления, для которого и будут отбираться данные.
Для этих целей используются поля, которые передаются в конструктор:
\begin{itemize}
    \item \texttt{min\_pressure};
    \item \texttt{max\_pressure}.
\end{itemize}

Поле \texttt{min\_pressure} задаёт минимальную границу давления, для которого будут отобраны значения.
Поле \texttt{max\_pressure} задаёт максимальную границу давления, для которого будут отобраны значения.
Оба этих параметра передаются в контруктор класса \texttt{COParser}.

Метод \texttt{parse()} используется для преобразования полученных данных в значения, которые можно проанализировать.
На вход принимает данные об индексе загрязнения монооксидом углерода в формает JSON.
Возвращает список полученных значений индекса загрязнения монооксидом углерода.



\subsection{Классы модуля отправки загрузчика}
После обработки данных, они отправляются в соответсвующий топик в платформе kafka. 
В качестве ключа сообщения используется преобразованная строка, которая содержит информацию о типе api, географических координатах и годе.
Для отправлении сообщений используется класс \texttt{KafkaAdapter}.

\subsubsection{Класс \texttt{KafkaAdapter}}

Данный класс используется для взаимодействия с платформой kafka.
В частности, используется для отправки сообщений.
Для каждого типа даных используется свой топик.
Такой способ позволяет производить обработку конкретного типа данных.

Для обеспечения работы с платформой, необходимо произвести конфгурацию отправителя.
За решение этой задачи ответственнен экземпляр класса \texttt{KafkaProducerConfig}.
Этот класс как раз хранит все необходимые параметры конфигурации, которые необходимы для осуществления взаимодействия с упомянутой платформой.
Используемые при конфигурации параметры:
\begin{itemize}
    \item \texttt{bootstrap\_servers}. Указывает адреса kafka серверов в формате <<host[:port]>>;
    \item \texttt{client\_id}. Указывает уникальный идентификатор клиента в платформе kafka;
    \item \texttt{key\_serializer}. Указывает имя класса сериализатора для ключа в сообщении;
    \item \texttt{value\_serializer}. Указывает имя класса сериализатора для значения в сообщении;
    \item \texttt{acks}. Указывает требуемое количество подтверждений от kafka серверов;
    \item \texttt{compression\_type}. Указывет тип используемого сжатия;
    \item \texttt{retries}. Указывает количество попыток отправить данные заново при неудаче;
    \item \texttt{batch\_size}. Указывает максимальный размер пакета для отправки;
    \item \texttt{max\_request\_size}. Указывает максимальный размер запроса;
    \item \texttt{request\_timeout\_ms}. Указывает максимальное время ожидания ответа при отправке пакета в миллисекундах;
    \item \texttt{security\_protocol}. Указывает используемый протокол для связи с брокерами kafka.
\end{itemize}

После настройки можно отправлять сообщения.
Для этого используется метод \texttt{send\_message()}.
Метод принимает топик, в который будет отправляться сообщение, само сообщение, и ключ.
Ключ из себя представляет преобразованную строку, которая содержит информацию о типе api, географических координатах и годе.
Такой способ используется для того, чтобы при получении сообщения, можно было узнать, от куда были получены данные.
Если указанные брокеры недоступны, либо отправка не осуществилась по другой причине, то будет выброшено исключение, которое будет обработано вызывающим функционалом.






\subsection{Классы модуля приёма обработчика}
Для анализа данных необходимо их сначала получить, и перенаправить в анализирующую систему.
Для этого как раз используется kafka приёмник.
Его роль исполняет класс \texttt{KafkaConsumerAdapter}.

Так как для каждого типа даных используется свой топик, то можно осуществить подписку только на те топики, где располагаются интересующие данные.
Для потоковой обработки данных, в kafka применяется метод подписки.
Получатель может подписаться на интересующие его топики, и тем самым, получать актуальную информацию, как только данные поступят в платформу.
Такая обработка осуществляется пакетами, которые берутся из значений, которые поступили в систему в определённое временное окно.
Так как существует задержка между тем моментом, когда сообщение поступило в систему и тем, когда это сообщение будет получено, то применяется понятие водяного знака (англ. watermark).
В kafka каждое сообщение имеет также временной штамп (англ. timestamp), который соответствует времени создания сообщения.
Водяной знак позволяет отсеивать сообщения, которые пришли позже установленного времени.
При чём, если временной штамп сообщения походит под текущее окно, то оно попадает в текущий пакет.
Apache Spark позволяет описать процесс обработки всего потока.
Все описанные операции будут применяться к каждому полученному пакету за установленное окно.


\subsubsection{Класс \texttt{KafkaConsumerAdapter}}

Данный класс используется для взаимодействия с платформой kafka для считывания из неё данных.
Для обеспечения работы с платформой, необходимо произвести конфгурацию приёмника.
За решение этой задачи ответственнен экземпляр класса \texttt{KafkaConsumerConfig}.
Этот класс как раз хранит все необходимые параметры конфигурации, которые необходимы для осуществления взаимодействия с упомянутой платформой.
Используемые при конфигурации параметры:
\begin{itemize}
    \item \texttt{bootstrap\_servers}. Указывает адреса kafka серверов в формате <<host[:port]>>;
    \item \texttt{client\_id}. Указывает уникальный идентификатор клиента в платформе kafka;
    \item \texttt{group\_id}. Указывает уникальный идентификатор группы получателей в платформе kafka;
    \item \texttt{key\_deserializer}. Указывает имя класса десериализатора для ключа в сообщении;
    \item \texttt{value\_deserializer}. Указывает имя класса десериализатора для значения в сообщении;
    \item \texttt{auto\_offset\_reset}. Указывает правило для сбрасывания смещения при переподключении;
    \item \texttt{enable\_auto\_commit}. Указывает возможность использования автоматического сохранения текущего смещения в разделе;
    \item \texttt{auto\_commit\_interval\_ms}. Указывает интервал, с которым происходит автоматическое сохранение смещения;
    \item \texttt{session\_timeout\_ms}. Указывает максимальное время ожидания специального сигнала, отсылаемого брокером получателю;
    \item \texttt{security\_protocol}. Указывает используемый протокол для связи с брокерами kafka.
\end{itemize}

Все эти настройки предоставляются с помощью экземпляра класса \texttt{KafkaConsumerConfig}.
Если указанные брокеры недоступны, либо получение не осуществилась по другой причине, то будет выброшено исключение, которое будет обработано вызывающим функционалом.
Метод \texttt{create\_steam()} используется для создания потока, который будет обрабатываься дальше с помощью Apache Spark.


\subsection{Классы модуля анализа обработчика}
Модуль анализа используеся для обработки значений, которые поступают из системы kafka.
Сама обработка производится с помощью потоков в Apache Spark.

Поток представляет из себя постоянно появляющиеся пакеты данных, которые представлены в виде Resilent Distributed Dataset (RDD).
Данные объекты из себя представляют абстракции распределённых данных.
Сами данные создаются и обрабатываются непосредственно на этапе исполнения.

\subsubsection{Класс \texttt{StreamPerformer}}
Данный класс используется для обработки потока RDD.
Также этот класс обязательно должен быть сериализуемым, так как этот класс используется для обработки.
Это значит, что объект этого класса будет сериализован и отправлен на используемые рабочие машины, которые использует Apache Spark.
На самих машинах этот объект десериализуется и может быть использован для обработки данных.

Метод \texttt{processStream()} используется для обработки всего потока.
Операции будут применены к каждому RDD в потоке.
И так это будет продолжаться, пока процесс не будет завершён извне.
На полученных данных разворачивается внутренняя таблица.
Полученная таблица в дальнейшем будет использована для предоставления результатов.

Метод \texttt{process()} используется для обработки одного RDD.


\subsubsection{Класс \texttt{COStreamPerformer}}
Данный класс используется для обработки потока RDD с данными об индексе загрязнения монооксидом углерода.
Также этот класс обязательно должен быть сериализуемым, так как этот класс используется для обработки.

Метод \texttt{processStream} используется для обработки всего потока.
Операции будут применены к каждому RDD в потоке.
И так это будет продолжаться, пока процесс не будет завершён извне.
На полученных данных разворачивается внутренняя таблица.
Полученная таблица в дальнейшем будет использована для предоставления результатов.

Метод \texttt{process()} используется для обработки одного RDD.


\subsubsection{Класс \texttt{SOStreamPerformer}}
Данный класс используется для обработки потока RDD с данными об индексе загрязнения диоксидом серы.
Также этот класс обязательно должен быть сериализуемым, так как этот класс используется для обработки.

Метод \texttt{processStream()} используется для обработки всего потока.
Операции будут применены к каждому RDD в потоке.
И так это будет продолжаться, пока процесс не будет завершён извне.
На полученных данных разворачивается внутренняя таблица.
Полученная таблица в дальнейшем будет использована для предоставления результатов.

Метод \texttt{process()} используется для обработки одного RDD.


\subsubsection{Класс \texttt{NOStreamPerformer}}
Данный класс используется для обработки потока RDD с данными об индексе загрязнения диоксидом азота.
Также этот класс обязательно должен быть сериализуемым, так как этот класс используется для обработки.

Метод \texttt{processStream()} используется для обработки всего потока.
Операции будут применены к каждому RDD в потоке.
И так это будет продолжаться, пока процесс не будет завершён извне.
На полученных данных разворачивается внутренняя таблица.
Полученная таблица в дальнейшем будет использована для предоставления результатов.

Метод \texttt{process()} используется для обработки одного RDD.

\subsubsection{Класс \texttt{OZStreamPerformer}}
Данный класс используется для обработки потока RDD с данными об индексе загрязнения озоном.
Также этот класс обязательно должен быть сериализуемым, так как этот класс используется для обработки.

Метод \texttt{processStream()} используется для обработки всего потока.
Операции будут применены к каждому RDD в потоке.
И так это будет продолжаться, пока процесс не будет завершён извне.
На полученных данных разворачивается внутренняя таблица.
Полученная таблица в дальнейшем будет использована для предоставления результатов.

Метод \texttt{process()} используется для обработки одного RDD.


\subsection{Классы модуля сохранения обработчика}
После обработки данные могут быть сохранены в разных форматах, которые поддерживает Apache Spark.
Сохранение обработанных данных позволит развернуть полноценную таблицу на файле, и использовать уже готовые данные для последующего анализа.

Для сохранения используются несколько форматов, поддерживаемых Apache Spark:
\begin{itemize}
    \item \texttt{orc}. Данный формат эффективен для хранения больших объёмов данных, так как использует сжатие. Также данный формат структурированный, что позволяет использовать пропуск полей (англ. file prunning). Это значит, что при чтении такого файла для определённого запроса, Apache Spark может пропускать не используемые в запросе поля, и не тратить время на их распаковку;
    \item \texttt{csv}. Данный формат эффективен для хранения данных в строгой структуре;
    \item \texttt{json}. Данный формат эффективен для хранения сложной структуры данных;
    \item \texttt{parquet}. Данный формат эффективен для файлов, которые часто подвергаются чтению, и редко подвергаются записи;
    \item \texttt{avro}. Данный формат эффективен для сложных данных с изменяемой структурой.
\end{itemize}

Также помимо простого сохранения в файл, Apache Spark позволяет использовать разбиение на разделы (англ. partition) и корзины (англ. bucketing).
Разбиение по разделам означает то, что каждое уникальное значение для указаного поля будет представлять из себя отдельную директорию, в которой будут храняться данные с этим значением.
Такой способ крайне удобен при сохранении данных с каким-то типом.
В итоге, каждый тип буде размещён в отдельную директорию.
Использование корзин, в свою очередь, является аналогом хэш-таблицы.
Все значения разиваются на определённоё количество корзин с помощью нахождения хэш-функции.
Тем самым, при попытке найти запись с определённым значением поля, которое было разбито на корзины - необходимо вычислить хэш сравниваемого значения, определить корзину, уоторая соответствует полученному значению, и искать нужную запись только в этой корзине.

\subsubsection{Класс \texttt{SaverConfig}}
Данный класс используется конфигурирования сохранения файлов после обработки.
Для конфигурации используются следующие поля:
\begin{itemize}
    \item \texttt{format}. Формат, в котором будут сохранены данные;
    \item \texttt{path}. Путь к файлу, в который будут сохранены данные;
    \item \texttt{mode}. Режим записи;
    \item \texttt{partition}. Поля, по которым будет производиться разделение;
    \item \texttt{bucketing}. Поля, по которым будет производится разбиение на корзины;
    \item \texttt{bucket\_count}. Количество корзин, на которые будут разбиваться данные.
\end{itemize}

Получение соответствующих полей осуществляется с помощью методов:
\begin{itemize}
    \item \texttt{get\_format}. Для получения поля \texttt{format};
    \item \texttt{get\_path}. Для получения поля \texttt{path};
    \item \texttt{get\_mode}. Для получения поля \texttt{mode};
    \item \texttt{get\_partition}. Для получения поля \texttt{partition};
    \item \texttt{get\_bucketing}. Для получения поля \texttt{bucketing};
    \item \texttt{get\_bucket\_count}. Для получения поля \texttt{bucket\_count}.
\end{itemize}

\subsubsection{Класс \texttt{DataSaver}}
Данный класс используется для сохранения потока RDD.
Сам RDD преобразуется в \texttt{DataFrame} и далее сохраняется в локальную или распределённую файловую систему.

Для конфигурации используются следующие поля:
\begin{itemize}
    \item \texttt{format}. Определяет формат, в котором будут сохранены данные;
    \item \texttt{path}. Указывает путь к файлу, в который будут сохранены данные;
    \item \texttt{mode}. Определяет режим записи;
    \item \texttt{partition}. Определяет поле, по которому будет производиться разделение;
    \item \texttt{bucketing}. Определяет поле, по которому будет производится разбиение на корзины;
    \item \texttt{bucket\_count}. Определяет количество корзин, на которые будут разбиваться данные.
\end{itemize}

Все эти поля предоставляются с помощью экземпляра класса \texttt{SaverConfig}.

При использовании \texttt{partition} данные с одинаковыми значениями указаных полей будут располагаться в одной директории.
По умолчанию происходит разбиение по полю \texttt{topic}.
Тем самым данные с одинаковым топиком будут располагаться в одной директории с названием например \texttt{topic=co_topic}.

При использовании \texttt{bucketing} данные также будут распределяться по директориям, но другим образом.
Для указанного поля высчитывается хэш-функция.
Далее от указанной хэш-функции берётся значение по модулю, заданного с помощью \texttt{bucket\_count}.
Данные с одинаковым полученным значением будут располагаться в одной директории.

\subsubsection{Класс \texttt{StreamPerformer}}

Данный класс используется для преобразования и сохранения потока RDD.
RDD, полученный из Kafka топика преобразуется к кортежу со следующими полями:

\begin{itemize}
    \item \texttt{topic} (String);
    \item \texttt{year} (Int);
    \item \texttt{latitude} (Long);
    \item \texttt{longitude} (Long);
    \item \texttt{value} (Double).
\end{itemize}

Поле \texttt{topic} получается из метаинформации принятого сообщения из Kafka.
Поля \texttt{year}, \texttt{latitude} и \texttt{longitude} закодированы в ключе сообщения.
Поле \texttt{value} получается из значения в сообщении.

Далее полученный RDD при помощи объекта класса \texttt{DataSaver} преобразуется в RDD и сохраняется в файловой системе.

\subsubsection{Класс \texttt{AppConfig}}
Данный класс используется для настройки работы приложения.
Объект рассматриваемого класса содержит в себе объекты таких классов, как:
\begin{itemize}
    \item \texttt{KafkaConsumerConfig};
    \item \texttt{SaverConfig}.
\end{itemize}

Также содержит собственные поля конфигурации, такие как:
\begin{itemize}
    \item \texttt{sparkMaster};
    \item \texttt{streamTime};
    \item \texttt{COInputTopic};
    \item \texttt{NOInputTopic};
    \item \texttt{OZInputTopic};
    \item \texttt{SOInputTopic}.
\end{itemize}

Поле \texttt{sparkMaster} указывает на адрес Spark-мастера.
В случае, если используется вариант работы в локальном режиме, то в поле необходимо установить \texttt{local\[\*\]}.
В данной конфигурации указывается максимальное количество используемых ядер.
Звёздочка определяет, что использоваться будут все доступные ядра.

Поле \texttt{streamTime} указывает на продолжительность окна, в течении которого будут агрегироваться сообщения.
После агрегирования, все сообщения, которые были приняты в течении используемого окна, поступают на дальнейшую обработку в виде объекта \texttt{RDD<ConsumerRecord<String, String>>}.

Из-за того, что сообщения могут придти на Spark-worker с опозданием, используется такое понятие как водяной знак (англ. watermark).
С помощью водяного знака можно отловить сообщения, которые должны попасть в одно окно.
В качестве водяного знака обычно используют сравнение временной отметки сообщения (англ. timestamp).

Поле \texttt{COInputTopic} определяет топик, в котором располагаются сообщения с информацией об индексе загрязнения монооксидом углерода ($ \text{CO} $).
Данный топик выступает в качестве одного из топиков, к которым осуществляется подписка.

Поле \texttt{OZInputTopic} определяет топик, в котором располагаются сообщения с информацией об индексе загрязнения озоном ($ \text{O}_{\text{3}} $).
Данный топик выступает в качестве одного из топиков, к которым осуществляется подписка.

Поле \texttt{SOInputTopic} определяет топик, в котором располагаются сообщения с информацией об индексе загрязнения диоксидом серы ($ \text{SO}_{\text{2}} $).
Данный топик выступает в качестве одного из топиков, к которым осуществляется подписка.

Поле \texttt{NOInputTopic} определяет топик, в котором располагаются сообщения с информацией об индексе загрязнения диоксидом азота ($ \text{NO}_{\text{2}} $)..
Данный топик выступает в качестве одного из топиков, к которым осуществляется подписка.


\subsection{Модуль визуализации обработчика}
Для представления результатов используется Apache Zeppelin.
Этот модуль представляет из себя набор интерактивных документов, которые используются для предоставления в удобном виде полученных результатов.
Данные получаются из таблиц, созданных с помощью Apache Spark на предыдущем этапе.
Каждый API предоставляется отдельной таблицей, так что все интерактивные документы могут работать с определённой таблицой.

При обработке данных в режиме реального времени, данные записываются в виде текстовых файлов в формате csv в определённую директорию.
Данная директория может располагаться как локально, так и на распределённой файловой системе.
При работе в локальном режиме, директория с сохранёнными файлами монтируется в контейнер, так что остальные компоненты системы, а также хостовая машина имеет доступ к обработанным данным.

В состав Apache Zeppelin входит множество интерпретаторов, таких как:
\begin{itemize}
    \item Alluxio;
    \item Beam;
    \item BigQuery;
    \item Cassandra;
    \item Elasticsearch;
    \item Flink;
    \item Geode;
    \item Groovy;
    \item HBase;
    \item HDFS;
    \item Hive;
    \item Ignite;
    \item JDBC;
    \item Kylin;
    \item Lens;
    \item Livy;
    \item Mahout;
    \item Markdown;
    \item Neo4j;
    \item Pig;
    \item Postgresql;
    \item HAWQ;
    \item Python;
    \item R;
    \item SAP;
    \item Scalding;
    \item Scio;
    \item Shell;
    \item Spark.
\end{itemize}

Из всех этих компонентов в разрабатываемом приложении понадобятся только Spark, Livy, Python.
Spark интерпретатор в свою очередь предлагает сразу два интерфейса использования.
Можно использовать как нативный для Spark язык Scala, либо можно использовать аналогичный ему Python.
Последний вариант использование называется Pyspark и также применяется в Zeppelin.

В Zeppelin используются интерактивные документы, которые представляют из себя набор параграфов.
У каждого параграфа устанавливается используемый для него интерпретатор.
Таким образом, можно использовать несколько языков в одном интерактивном документе.

В первом параграфе используется Spark. 
Он вычитывает текущие обработанные данные из установленного пути.
Так как разбиение идёт по топику, то и файлы можно вычитывать сразу для интересующего индекса загрязнений.

Файлы хранятся в формате csv, что позволяет легко их преобразовать в полноценные записи с несколькими полями.
После преобразования используется Livy для предоставления текущих данных.
Данный инструмент позволяет в приятной форме представлять данные в виде таблиц, графиков и диаграмм.

В следующем параграфе используются возможности Zeppelin для того, чтобы получить интересующие координаты, для которых будут браться данные.
Далее по установленным координатам происходит выборка значений.
Выбранные значения заносятся во временную таблицу.
Таким образом происходит обмен таблицами между разными интерфейсами Spark.
Также по этой таблице вновь при помощи Livy строится график для представления текущих значений.

В следующем параграфе используется Python.
Для загрузки уже подготовленных данных, происходит вычитывание временной таблицы.
Далее происходит переход к обычному списку значений.

Дальнейшая часть представляет из себя регресионный линейный анализ методом наименьших квадратов (МНК).
Регресионный линейный анализ является процессом нахождения линейной зависимости исходя из нескольких значений.
В нашем случае идёт зависимость индекса загрязнения от времени.
При нахождении этой зависимости, появляется возможность предсказать примерное значение индекса загрязнения через некоторое время.
Конечно же полученное значение будет совпадать с действительным только в том случае, если зависимость действительно является линейной.
Для упрощения будем считать, что эта зависимость является таковой.

Метод наименьших квадратов для функции от одной переменной графически можно представить как нахождение такой прямой, до которой каждая точка на плоскости будет иметь минимально возможное расстояние.
Найденная прямая как раз будет описываться линейным уравнением, которое и будет показывать примерную зависимость одной координаты от другой.

