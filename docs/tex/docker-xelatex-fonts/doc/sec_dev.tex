\pagebreak
\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:dev}

\def\websockHandshakeScheme{ГУИР.400201.079 ПД2}

В прошлом разделе были описаны функции, имеющиеся в разрабатываемом программном обеспечении. 
В данном разделе будет описана разработка ключевых алгоритмов для данного дипломного проекта.

\subsection{Алгоритм рукопожатия для сервера веб-сокетов}

На схеме \websockHandshakeScheme{} изображен алгоритм рукопожатия, который
требуется имплементировать для сервера веб-сокетов. По стандарту~\cite{websock_rfc}
его требуется выполнить при установлении соединения.

Клиент пытается связаться с веб-сокет сервером для общения. Для этого на
требуемый порт посылается HTTP-запрос с обязательными полями:
\begin{itemize}
    \item \texttt{Upgrade: websocket}
    \item \texttt{Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==}
\end{itemize}

Первое поле указывает на то, что клиент предлагает продолжить общение
на данном порту протокола TCP по протоколу WebSocket вместо HTTP.
Проверка на наличие этого поля производится в блоках G07, J07, C09 указанной выше
схемы.

Второе поле в списке содержит ключ для установления соединения, сгенерированный
клиентом случайным образом. Он передается в кодировке base64. Для данного примера
ключом является строка \texttt{dGhlIHNhbXBsZSBub25jZQ==}.

При получении запроса на установление соединения, сервер принимает запрос,
если не превышено количество одновременных подключений, производит инициализацию
внутреннего состояния соединения (блоки C01, E01, G01, J01, L01) и
производит прием данных (последовательность блоков от N01 до A07) с их
одновременным анализом.

Для подтверждения установления соединения, производит проверку присутствия
обязательных полей (отображено на блоках A09, C09, E09).
При выполнении всех требуемых условий, сервер добавляет константную строку
\texttt{258EAFA5-E914-47DA-95CA-C5AB0DC85B11} к переданному ключу (производится
в блоке G09), производит необходимые преобразования (проиллюстрированы на блоках
J09 и L09) и генерирует ответ. Он содержит подтверждение обновления протокола
и результаты преобразований, описанных выше. Ответ передается клиенту и соединение
считается установленным.

Таким образом, схема \websockHandshakeScheme{} содержит полный алгоритм рукопожатия
с подробно описанным приемом и обработкой запроса на установление соединения.
Вычисление контрольной суммы SHA-1 на этапе преобразования ключа в ответ
негативно сказывается на скорости работы устройства, но является обязательной частью
протокола и производится единожды для каждого соединения.

\subsection{Алгоритм перенаправления и сортировки собранной статистики}

Алгоритм перенаправления и сортировки собранной статистики раскладывает
принятую информацию по почтовым ящикам в зависимости от источника сообщения.
Поскольку посылаемые данные могут быть слишком длинными для пересылки в
одном сообщении, они могут посылаться по частям с указанием окончания флага посылки.
Модуль межъядерного взаимодействия отдает посылки в порядке их отправления.
Но в один момент времени два ядра одновременно могут посылать информацию,
которая не может быть передана одним сообщением. В результате может возникнуть
перемешивание частей посылок разных ядер, что усложняет использование
возможности протокола веб-сокетов по дроблению пересылаемой информации на
несколько посылок.

Алгоритм реализован в функции \texttt{GlobalBenchmark\_Thread}, которая
является одной из ключевых для модуля глобального сбора сообщений. Как было сказано
ранее, данная функция принимает два параметра: \texttt{UArg a0} и \texttt{UArg a1}.
Оба параметра имеют тип \texttt{UArg}, определенный в заголовочном файле
\texttt{xdc/runtime/Types.h} и эквивалентны типу \texttt{unsigned int} языка
\texttt{C}. Значения обоих параметров не используются в работе алгоритма.

Распишем данный алгоритм по шагам:
\begin{enumerate_step}
    \item Создаем локальную переменную \texttt{receiver} типа
    \texttt{msg\_recv\_ctx\_t} для хранения контекста получателя сообщений из
    модуля межъядерного взаимодействия.
    \item Инициализируем контекст получателя сообщений вызовом функции
    \texttt{IpcMsg\_RecvInit}. Передаем в функцию идентификатор принимающей
    стороны сообщений статистики.
    \item Запоминаем код возврата из функции инициализации \texttt{IpcMsg\_RecvInit}
    в переменную \texttt{ret\_code}. Если код возврата является кодом успешной
    инициализации, переходим к шагу \ref{i:gbt:initSuccess}.
    \item Оповещаем пользователя об обнаружении ошибки инициализации приемной
    части сообщений с указанием кода возврата \texttt{ret\_code}.
    \item \label{i:gbt:initSuccess} Создаем локальную переменную \texttt{msg}
    типа \verb|sirius_msg_t*| для хранения указателя на принятое сообщение из
    модуля межъядерного взаимодействия.
    \item Принимаем сообщение в ускоренном режиме путем вызова функции
    \verb|SiriusMsg_RecvMessageNC|. В качестве аргументов указываем контекст
    принимающей стороны сообщений, адрес, куда требуется записать указатель на
    принятое сообщение, и время ожидания сообщения, эквивалентное бесконечности
    в данной функции.
    \item Запоминаем код возврата из функции инициализации
    \verb|SiriusMsg_RecvMessageNC| в переменную \texttt{ret\_code}.
    Если код возврата является кодом успешного приема сообщения, и пользователь
    включил режим отладки, переходим к шагу \ref{i:gbt:recvSuccessDbg}.
    Если код возврата является кодом успешного приема сообщения переходим
    к шагу \ref{i:gbt:recvSuccess}.
    \item Оповещаем пользователя об ошибке приема сообщения с указанием
    кода возврата \verb|ret_code|.
    \item Ждем одну секунду. Переходим к шагу \ref{i:gbt:end}.
    \item \label{i:gbt:recvSuccessDbg} Информируем пользователя об успешном приеме
    сообщения.
    \item \label{i:gbt:recvSuccess} Создаем переменную \verb|mh| типа \verb|Mailbox_Handle|, которая хранит
    идентификатор почтового ящика для пересылки полученного сообщения.
    \item Из полученного сообщения извлекаем идентификатор
    узла источника сообщений в переменную \verb|src| типа \verb|msg_node_id_t|.
    Если источником сообщения является ядро HOST, переходим к шагу
    \ref{i:gbt:idHost}. Если источником сообщения является ядро IPU1, переходим
    к шагу \ref{i:gbt:idIpu1}. Если источником сообщения является ядро DSP1,
    переходим к шагу \ref{i:gbt:idDsp1}. Если источником сообщения является
    ядро DSP2, переходим к шагу \ref{i:gbt:idDsp2}.
    \item Информируем пользователя об обнаружении неопознанного
    источника сообщений. Переходим к шагу \ref{i:gbt:freeMsg}.
    \item \label{i:gbt:idHost} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра HOST. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idIpu1} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра IPU1. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idDsp1} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра DSP1. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idDsp2} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра DSP2.
    \item \label{i:gbt:mailboxSelected} Отправляем полученное сообщение \verb|msg|
    в почтовый ящик, идентификатор которого записан в переменной \verb|mh|,
    с помощью функции \verb|Mailbox_post|. В качестве времени ожидания добавления
    сообщения используется время, равное нулю.
    \item В переменную \verb|ret_code| записываем результат выполнения функции
    \verb|Mailbox_post|. Если код возврата является кодом успешного
    отправления сообщения, переходим к шагу \ref{i:gbt:mailboxPostSuccess}.
    \item Информируем пользователя о невозможности добавления сообщения в почтовый
    ящик.
    \item \label{i:gbt:freeMsg} Удаляем из межъядерного буфера принятое сообщение.
    \item \label{i:gbt:mailboxPostSuccess} Если у пользователя выключен режим
    отладки, переходим к шагу \ref{i:gbt:end}.
    \item Информируем пользователя об окончании перенаправления сообщения.
    \item \label{i:gbt:end} Завершение итерации алгоритма. Переход к шагу
    \ref{i:gbt:initSuccess}.
\end{enumerate_step}

Таким образом, в данном подразделе был описан алгоритм работы демультиплексирования
сообщений текущего состояния ядер системы. Каждое принятое сообщение передается
в свой выделенный почтовый ящик для дальнейшего форматирования, мультиплексирования
и передачи модулю сервера веб-сокетов.

\subsection{Алгоритм разбора почтовых ящиков в модуле глобального сбора статистики}

Алгоритм перенаправления и сортировки собранной статистики перенаправляет
принятую информацию по почтовым ящикам в зависимости от ядра процессора,
которое отправило сообщение. Текущая версия позволяет разбирать до 32
очередей сообщений в одном потоке и мультиплексировать их в сообщения веб-сокетов.

Алгоритм описан в функции \verb|websock_workload_sender_task|. Поскольку
он является задачей TI-RTOS, ему требуется передать в качестве аргументов
два параметра: \verb|UArg a0| и \verb|UArg a1|. Оба параметра имеют тип
\texttt{UArg}, определенный в заголовочном файле
\texttt{xdc/runtime/Types.h}. \verb|UArg| эквивалентен типу \texttt{unsigned int}
языка \texttt{C}. Значения параметров \verb|a0| и \verb|a1| не используются
в работе алгоритма.

Рассмотрим его подробнее:
\begin{enumerate_step}
    \item \label{i:wwst:begin} Создаем локальную переменную \verb|waited_or_event|
    типа \verb|unsigned int|, которая содержит список событий, которые данная
    задача будет ждать.
    \item Указываем в списке событий для ожидания \verb|MAILBOX_HOST_EVENT_ID|,
    \verb|MAILBOX_IPU1_EVENT_ID|, \verb|MAILBOX_DSP1_EVENT_ID| и
    \verb|MAILBOX_DSP2_EVENT_ID|.
    \item Создаем дескриптор события \verb|eh| и инициализируем его
    глобальным событием \verb|MAILBOX_EVENT|, к которому привязаны почтовые
    ящики.
    \item Ожидаем какого-либо события из переменной \verb|waited_or_event|
    в дескрипторе \verb|eh| с помощью функции \verb|Event_pend|.
    \item Записываем код возврата функции \verb|Event_pend| в переменную
    \verb|event| типа \verb|unsigned int|.
    \item Входим в критическую секцию \verb|websock_handle_lock_gate| с помощью
    вызова \verb|GateMutex_enter| для обеспечения атомарности работы с
    сетевыми дескрипторами, используемыми веб-сокетами.
    \item Сохраняем код возврата из функции \verb|GateMutex_enter| в переменную
    \verb|key_gate| типа \verb|IArg| для выхода из критической секции.
    \item Проверяем наличие соединений с веб-сокет сервером. Если таковых нет,
    переходим к пункту \ref{i:wwst:freeMailBoxOnly}.
    \item Получаем дескриптор сокета для работы с клиентом. Сохраняем его в
    переменную \verb|s| типа \verb|SOCKET|.
    \item Открываем сессию для работы с файловыми дескрипторами в текущей
    задаче с помощью вызова функции \verb|fdOpenSession|.
    \item Разрешаем доступ к пользовательскому сокету \verb|s| из нескольких
    потоков одновременно.
    \item \label{i:wwst:send} Отправляем пользователю информацию, которая
    просигнализировала о своей доступности в дескрипторе события \verb|eh|
    и указана в коде возврата \verb|event|. Отправка производится с помощью
    модуля сервера веб-сокетов путем вызова \verb|websock_benchmark_send|.
    \item Получаем список текущих событий, произошедших в дескрипторе
    \verb|eh|, без ожидания их происхождения с помощью вызова функции
    \verb|Event_pend|. Сохраняем их в переменную \verb|event|.
    \item Анализируем текущие события, сохраненные в \verb|event|:
    если произошло хоть одно событие, переходим к шагу \ref{i:wwst:send}.
    \item Проверяем сокет на актуальность. Если дескриптор пользовательского
    сокета некорректен, переходим к шагу \ref{i:wwst:fdCloseDone}.
    \item Закрываем доступ к пользовательскому сокету в данном потоке
    вызовом функции \verb|fdClose|.
    \item \label{i:wwst:fdCloseDone} Закрываем сессию для работы с файловыми
    дескрипторами в текущей задаче с помощью вызова функции \verb|fdCloseSession|.
    Переходим к шагу \ref{i:wwst:leaveMutex}.
    \item \label{i:wwst:freeMailBoxOnly} Очищаем почтовые ящики с сообщениями
    без их отправки пользователю с помощью вызова \verb|websock_benchmark_send|.
    В качестве аргументов передаем туда произошедшие события заполнения почтовых
    ящиков \verb|event| и \verb|NULL| вместо указателя на дескриптор модуля
    сервера веб-сокетов.
    \item \label{i:wwst:leaveMutex} Выходим из критической секции с помощью вызова
    функции \verb|GateMutex_leave|, в которую передаем в качестве аргументов
    дескриптор критической секции \verb|websock_handle_lock_gate| и код возврата из
    функции входа в критическую секцию \verb|key_gate|.
    \item Завершение итерации алгоритма. Переход к шагу \ref{i:wwst:begin}.
\end{enumerate_step}

Таким образом, описанный выше алгоритм является задачей TI-RTOS, которая при
нормальной работе приложения никогда не должна завершить свое выполнение.
Алгоритм производит выбор способа работы с данными: производится только очистка
набора данных или производится их пересылка. Он также
позволяет избежать заторов и передавать данные полными сообщениями используя
в качестве исходящего транспорта модуль сервера веб-сокетов.

\subsection{Алгоритм пересылки сообщений из почтового ящика в модуль сервера
веб-сокетов}

При разборе почтовых ящиков сначала производится выбор ящика, который будет
источником сообщений в данный момент времени, а затем -- пересылка данных
по требуемому транспорту. Первая часть подробно описана в предыдущем алгоритме.
Вторая относится к текущему.

Сам алгоритм описан в функции \verb|websock_benchmark_send_mailbox|, которая
принимает два аргумента: \verb|Mailbox_Handle mh|, который и является дескриптором
почтового ящика, и \verb|WebSocketServer* wsserver|, который является дескриптором
сервера веб-сокетов. Рассмотрим алгоритм подробнее:
\begin{enumerate_step}
    \item Создаем локальную переменную \verb|is_last| типа \verb|bool|, которая
    хранит, является ли последнее принятое сообщение финальным
    в последовательности. Значение \verb|true| соответствует финальному сообщению.
    Значение \verb|false| -- не финальному.
    \item Инициализируем \verb|is_last| в состояние финального сообщения.
    \item \label{i:wbsm:mainLoopStart} Создаем переменную \verb|ipc_msg| типа
    \verb|sirius_msg_t*|, в которую будет записано сообщение из выбранной
    очереди.
    \item Создаем переменную \verb|timeout| типа \verb|uint32_t|, которая
    определяет время ожидания сообщения в почтовом ящике. Если \verb|is_last|
    соответствует финальному сообщению, то переменная примет значение нуля,
    иначе -- времени, определенному пользователем в переменной
    \verb|MAILBOX_WAIT_NEXT_PART_MS|.
    \item Принимаем сообщение из почтового ящика \verb|mh| с помощью вызова функции
    \verb|Mailbox_pend| с максимальным временем ожидания \verb|timeout|.
    \item Сохраняем результат работы функции \verb|Mailbox_pend| в переменную
    \verb|is_good|. Если результат работы не совпадает с успешным принятием данных,
    переходим к шагу \ref{i:wbsm:exitCheck}.
    \item Создаем локальную переменную \verb|msg_hdr| типа \verb|benchmark_msg_t*|,
    который содержит указатель на заголовок в принятом сообщении.
    \item Создаем локальную переменную \verb|msg_payload| типа \verb|uint8_t*|,
    который содержит указатель на данные в принятом сообщении из модуля межъядерного
    взаимодействия.
    \item Обновляем значение локальной переменной \verb|is_last| в соответствии
    с аналогичным полем в \verb|msg_hdr|.
    Если пользователь не включал отладочный режим, переходим к шагу
    \ref{i:wbsm:sendMsg}.
    \item Выводим заголовок принятого сообщения в отладочную консоль.
    \item Выводим тело принятого сообщения в отладочную консоль.
    \item \label{i:wbsm:sendMsg} Если не определен дескриптор сервера веб-сокетов,
    переходим к шагу \ref{i:wbsm:freeMsg}.
    \item Создаем буфер для форматирования сообщения \verb|msg_format|.
    \item Форматируем принятые из почтового ящика полезные данные \verb|msg_payload|
    с помощью вызова функции \verb|websock_benchmark_format_message|. Передаем
    в нее буфер \verb|msg_format|.
    \item Сохраняем результат работы функции \verb|websock_benchmark_format_message|
    в переменную \verb|msg_format_size| типа \verb|uint16_t|,
    которая содержит размер принятых полезных данных в сообщении. Если
    \verb|msg_format_size| равно нулю, переходим к шагу \ref{i:wbsm:freeMsg}.
    \item Отправляем данные с помощью модуля сервера веб-сокетов с помощью
    вызова функции \verb|websocketServer_sendData|. В качестве аргументов
    передаем \verb|msg_format|, \verb|msg_format_size| и \verb|is_last|.
    \item \label{i:wbsm:freeMsg} Освобождаем память в межъядерном буфере с
    помощью вызова функции \verb|IpcMsg_FreeMessageNC|. В качестве аргумента
    передаем принятый из почтового ящика указатель \verb|ipc_msg|. Переходим
    к шагу \ref{i:wbsm:mainLoopStart}.
    \item \label{i:wbsm:exitCheck} Если флаг \verb|is_last| находится в состоянии
    последнего сообщения, переходим к шагу \ref{i:wbsm:end}.
    \item Вывод сообщения о ненахождении последнего сообщения за отведенное время.
    Если не определен дескриптор сервера веб-сокетов, переходим к шагу
    \ref{i:wbsm:end}.
    \item Отправляем данные с помощью модуля сервера веб-сокетов с помощью
    вызова функции \verb|websocketServer_sendData|. В качестве аргументов
    передаем \verb|NULL| вместо указателя на буфер, нулевую длину и
    флаг принудительного окончания сообщения.
    \item \label{i:wbsm:end} Завершение алгоритма.
\end{enumerate_step}

Таким образом, в данном подразделе описан алгоритм очистки почтового ящика по
целым сообщениям, форматирования их и передачи в модуль сервера веб-сокетов.
Если конец сообщения не был получен за отведенное время,
сообщение будет принудительно окончено, а пользователю выдано соответствующее
уведомление.

В данном разделе были описаны ключевые алгоритмы работы системы. Они позволяют
эффективно проводить требуемые операции и соответствовать требованиям операционной
системы реального времени.