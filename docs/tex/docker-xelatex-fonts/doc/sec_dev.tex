\pagebreak
\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:dev}

\def\websockHandshakeScheme{ГУИР.400201.079 ПД2}

В прошлом разделе были описаны функции, имеющиеся в разрабатываемом программном обеспечении. 
В данном разделе будет описана разработка ключевых алгоритмов для данного дипломного проекта.

\subsection{Алгоритм получения данных с помощью внешнего сервиса}

В качестве источника данных может быть использовано как локальное хранилище, так и внешнее.
Если данные не были обнаружены в локальном хранилище, то они должны быть получены из внешнего сервиса.

В качестве локального хранилища может выступать как распределённая файловая система, так и локальная файловая система.
Для получения данных из подобного хранилища используется соответствующий адаптер:

\begin{itemize}
    \item \texttt{DistributedFileSystem};
    \item \texttt{DefaultFileSystem}.
\end{itemize}

Оба этих адаптера реализуют интерфейс \texttt{FileSystemAdapter}, который и используется для получения данных из локального хранилища.
С помощью файла конфигурации определяется используемая файловая система, а также параметры, которые необходимы для указания директории, в которой будут расположены хранимые данные.

В хранилище данные хранятся при помощи разбиения на корзины, как это используется в Apache HIVE.
Это означает, что данные за один год будут расположены в одной директории.
Данный подход позволяет развернуть таблицу на этих данных с помощью Apache HIVE.

Перед обращением к сервису происходит проверка запрашиваемых значений в используемой файловой системе.
Для этого запрашиваемые параметры преобразуются в строку с помощью метода \texttt{to\_file\_path}.
Поиск осуществляется в директории с запрашиваемым годом и с названием файла, полученным после преобразования параметров в название.
Если такой файл был найден, то данные из файла отправляются на дальнейшую обработку.
В противном случае производится запрос к внешнему сервису.

Для получения данных из внешнего сервиса OpenWeatherMap используется HTTP протокол.
Данные передаются в формате JSON.
Для успешного подключения необходимы следующие параметры:
\begin{itemize}
    \item API key. Специальный ключ, который предоставляется сервисом OpenWeatherMap при оформлении подписки;
    \item API Url. Адрес используемого API.
\end{itemize}

Для определения критериев выборки, на текущий момент используются следующие параметры:
\begin{itemize}
    \item географическая широта;
    \item географическая долгота;
    \item диапазон времени.
\end{itemize}

При установке соединения, на стороне сервиса происходит проверка переданного ключа.
Для используемого API на текущий момент существуют ограничения на количество запросов в промежуток времени.
По этой причине сервер проверяет количество использований переданного ключа в течении установленного промежутка.
Если текущий запрос укладывается в ограничение, то сервер отправляет запрошенные данные.
В случае, если количество запросов было превышено, то соединение удерживается на стороне сервера до тех пор, пока не истечёт установленный промежуток времени.


В любом случае, данные будут получены, и переданы на дальнейший этап обработки.
Так как данные будут получены в формате JSON, то их необходимо обработать, чтобы предоставить их в том формате, в котором они могут быть обработаны.

Полученные данные попадают в один из следующих методов в зависимости от используемого API:
\begin{itemize}
    \item \texttt{parse\_co};
    \item \texttt{parse\_so};
    \item \texttt{parse\_oz};
    \item \texttt{parse\_no}.
\end{itemize}

Каждый упомянутый выше метод используется для преобразования полученных данных из соответствующего JSON формата в список значений.
Полученный список представляет из себя выборку значений индекса загрязнения, которые соответствуют установленному критерию.
В качестве используемого критерия выступает атмосферное давление в области, где было проведено измерение индекса загрязнения.
Как было указано ранее, для выборки используются значения, полученные в пределах от %TODO add borders%.

После преобразования и выбора необходимых значений, они сохраняются в используемой файловой системе.
Путь сохраняемого файла определяется таким же способом, как это происходила при поиске.
Директория определяется с помощью года, за который были запрошены данные, а название файла определяется аналогичным образом с помощью метода \texttt{to\_file\_path}.

Распишем данный алгоритм по шагам:
\begin{enumerate_step}
    \item Создаём объект класса \texttt{FileSystemAdapter} в зависимости от используемой файловой системы.
     Параметры для конструктора также определяются с помощью файла конфигурации;
    \item Преобразуем параметры для данных в строку с использованием метода \texttt{to\_file\_path} и сохраняем результат в переменную \texttt{file\_name};
    \item Выбирается параметр, используемый для разбиения для разделов. 
    Данный параметр также устанавливается с помощью файла конфигурации;
    \item С помощью вызова метода \texttt{ls} класса \texttt{FileSystemAdapter} получается список существующих директорий (разделов);
    \item Если раздел с требуемым параметром не существует, то он создаётся с помощью метода \texttt{mkdir} класса \texttt{FileSystemAdapter};
    \item В выбранном разделе с помощью метода \texttt{ls} класса \texttt{FileSystemAdapter} получается список хранимых файлов;
    \item В полученном списке происходит поиск файла с именем \texttt{file\_name};
    \item В случае, если искомый файл не был найден - происходит переход к шагу \ref{i:gbt:request};
    \item Значение вычитывается из файла с помощью метода \texttt{read\_file} класса \texttt{FileSystemAdapter};
    \item Результат в формате JSON сохраняется в переменную \texttt{value};
    \item Происходит переход к шагу \ref{i:gbt:sendMessage};
    \item \label{i:gbt:request} Создаётся объект класса \texttt{PollutionDumper} соответствующий используемому API. 
    Возможные варианты: \texttt{CODumper}, \texttt{NODumper}, \texttt{SODumper}, \texttt{OZDumper}.
    Параметры для создания этого объекта предоставляются с помощью файла конфигурации;
    \item У созданного объекта вызывается метод \texttt{dump} с текущими параметрами: географическая широта, географическая долгота, год;
    \item В вызываемом методе параметры преобразуются в адрес для GET запроса к внешнему сервису с помощью метода \texttt{to\_address};
    \item Осуществляется вызов HTTP запроса по полученному адресу;
    \item Происходит ожидание ответа;
    \item Проверяется статус ответа;
    \item В случае, если код статуса равен \texttt{200}, что соответствует корректному ответу, происходит переход к шагу \ref{i:gbt:successResponse};
    \item Выбрасывается исключение, которое обрабатывается и выводит сообщение об ошибке в лог;
    \item Происходит переход к шагу \ref{i:gbt:end};
    \item \label{i:gbt:successResponse} Ответ в формате JSON отправляется в соответствующий обработчик. 
    Возможные обработчики: функция \texttt{parse\_co}, функция \texttt{parse\_so}, функция \texttt{parse\_no}, функция \texttt{parse\_oz};
    \item В обработчике происходит преобразование данных в соответствующем формате JSON в список значений;
    \item Результат обработки сохраняется в переменную \texttt{value};
    \item Происходит запись переменной \texttt{value} в файл с именем \texttt{file\_name} с помощью метода \texttt{write\_file}.
    \item \label{i:gbt:sendMessage} Используемые параметры также преобразуются в формат JSON и сохраняется в переменную \texttt{key};
    \item Создаётся объект класса \texttt{KafkaSender}, с параметрами, указанными в файле конфигурации;
    \item Вызывается метод \texttt{send\_message} созданного объекта класса \texttt{KafkaSender}, в который передаются значения: \texttt{key}, \texttt{value}, топик и параметры. 
    Используемый топик также определяется с помощью файла конфигурации и зависит от текущего API;
    \item При успешной отправке, вызывается метод \texttt{callback}, который отправляет лог сообщение об успешной отправке сообщения, и выводит метаинформацию отправленного сообщения.
    \item Если отправка сообщения не произошла - выбрасывается исключение;
    \item \label{i:gbt:end} Происходит переход к следующей итерации.
\end{enumerate_step}


\subsection{Алгоритм отправки данных}

Подготовленные данные отправляются в kafka.
Для каждого типа индекса загрязнения выделен отдельный топик.
Каждое сообщение из себя представляет комбинацию ключа и значения.
Для ключа и значения устанавливается функция, которая будет преобразовывать данные при отправке в массив данных.
Данное преобразование необходимо для поддержки пользовательского формата данных и тем самым предоставляет возможность отправлять и хранить любой объект.

В качестве ключа используются параметры, которые были использованы при получении данных:
\begin{itemize}
    \item год, в котором было проведено измерение;
    \item географическая широта области, в которой было проведено измерение;
    \item географическая долгота области, в которой было проведено измерение.
\end{itemize}

Все эти параметры преобразуются в строку в формате JSON.
Полученная строка выступает в качестве ключа в отправляемом сообщении.
В качестве значения выступает список значений и соответствующего атмосферного давления, представляющий обработанные данные.
Значение также передаётся в формате JSON.

Каждый тип измерений отправляется в свой топик, который определяется с помощью файла конфигурации.
Также с помощью файла конфигураций устанавливаются правила поведения объекта, который отвечает за отправку сообщений.
Данные параметры уже были рассмотрены в предыдущем разделе.
Они влияют на алгоритм установки соединения, возможность восстановления потерянного соединения, безопасность передачи данных и размер пакета.

Также при отправке устанавливается функция обратного вызова (англ. \texttt{callback}), что позволяет получить метаинформацию отправленного сообщения и тем самым подтвердить успешную отправку сообщения.


\subsection{Алгоритм получения данных}

Получение данных осуществляется в режиме реального времени с помощью технологии Spark streaming.
Для осуществления подобного функционала используется пакетная обработка данных.
С помощью установленных в конфигурационном файле параметров создаётся виртуальный поток данных.
Такой поток данных является виртуальным, так как на самом деле потока как такового не существует, но с помощью него описываются действия, которые будут производиться с каждым полученным пакетом данных.
Подобный подход используется при описании вычислений на распределённом датасете, так как он существует только во время исполнения программы.

Виртуальный поток представляет из себя поток данных, которые будут получены из kafka топиков, которые приводятся в файле конфигурации.
Так как данные приходят в уже определённом формате, то их для начала необходимо разобрать на поля.
Из ключа сообщения можно получить переданные поля в формате JSON:
\begin{itemize}
    \item год, в котором было проведено измерение;
    \item географическая широта области, в которой было проведено измерение;
    \item географическая долгота области, в которой было проведено измерение.
\end{itemize}

Благодаря такой обработке, получаем распределённый датасет (RDD) уже с несколькими полями.
А так как значения сообщения из себя представляет список значений индекса и соответствующего атмосферного давления, то для каждой такой записи предыдущие параметры будут одинаковые.

В результате всех преобразований получается распределённый датасет (RDD), состоящий из нескольких полей:
\begin{itemize}
    \item год, в котором было проведено измерение;
    \item географическая широта области, в которой было проведено измерение;
    \item географическая долгота области, в которой было проведено измерение;
    \item атмосферное давление в области, в которой было проведено измерение;
    \item значение измеряемого индекса загрязнения.
\end{itemize}

Полученный датасет сохраняется в одном из следующих форматов:
\begin{itemize}
    \item \texttt{orc}. Данный формат эффективен для хранения больших объёмов данных, так как использует сжатие. Также данный формат структурированный, что позволяет использовать пропуск полей (англ. file prunning). Это значит, что при чтении такого файла для определённого запроса, Apache Spark может пропускать не используемые в запросе поля, и не тратить время на их распаковку;
    \item \texttt{csv}. Данный формат эффективен для хранения данных в строгой структуре;
    \item \texttt{json}. Данный формат эффективен для хранения сложной структуры данных;
    \item \texttt{parquet}. Данный формат эффективен для файлов, которые часто подвергаются чтению, и редко подвергаются записи;
    \item \texttt{avro}. Данный формат эффективен для сложных данных с изменяемой структурой.
\end{itemize}

Для полученных данных лучше всего подходят форматы \texttt{parquet} и \texttt{orc} по причине неизменяемости данных.
Однако формат может быть установлен на любой другой по желанию, так как данный параметр устанавливается в конфигурационном файле.

Также Apache Spark поддерживает разделение на разделы, что уже было отмечено выше.
В текущей ситуации под разделение лучше всего подходит поле с годом осуществления измерения.
Такое решение исходит из того, большая часть данных имеет одинаковый год, и при анализе часто будут браться данные по конкретному году.
Это позволит оптимизировать операции выбора и фильтрации данных, что повысит производительность системы.

На этих данных развёртывается таблица с помощью Apache Spark.
Это позволяет использовать преобразованные данные для дальнейшего анализа.
Как только будет получен новый пакет, после преобразования он также добавится уже в существующую таблицу, тем самым обеспечив её обновление в режиме реального времени.

Сами же пакеты данных образуются с помощью использования так называемого окна (англ. window).
Окно представляет из себя промежуток времени.
Данные, которые были получены за этот промежуток времени и являются пакетом.
Размер используемого окна также определяется с помощью конфигурационного файла.

В результате получается следующий алгоритм:
\begin{enumerate_step}
    \item Создаётся объект словаря \texttt{params};
    \item В словарь \texttt{params} добавляются параметры получателя, которые определяются с помощью файла конфигурации;
    \item Происходит инициализация spark-контекста;
    \item Устанавливается мастер, который определяется файлом конфигурации. 
    Используемый мастер может быть как локальный, так и удалённый;
    \item Устанавливаем окно для дальнейшей потоковой обработки;
    \item С помощью словаря \texttt{params}, созданного spark-контекста, а также топиков, которые определяются файлом конфигурации, создаётся объект виртуального потока - объект \texttt{stream} класса \texttt{DStream[String, String]};
    \item Для виртуального потока \texttt{stream} с помощью метода \texttt{mapPartition} определяется лямбда-функция, которая будет исполняться для каждого полученного раздела;
    \item В этой функции с помощью метода \texttt{map} определяется лямбда-функция, которая будет применяться к каждой записи в разделе;
    \item \label{i:gbt:map} В каждой записи получаем ключ и значение и записываем в переменные \texttt{key} и \texttt{value} соответственно;
    \item С помощью метода \texttt{parse\_key} получаем следующие поля: географическая широта (\texttt{latitude}), географическая долгота (\texttt{longitude}), год (\texttt{year});
    \item С помощью метода \texttt{parse\_value} получаем список со следующими полями: атмосферное давление (\texttt{pressure}), значение измерения (\texttt{value});
    \item Для каждого значения в обработанном \texttt{value} копируем соответствующие параметры (поля из обработанного \texttt{key});
    \item В результате трансформации получается распределённый датасет (RDD) со следующими полями: \texttt{latitude}, \texttt{longitude}, \texttt{year}, \texttt{pressure}, \texttt{value};
    \item Объединяется с другими полученными в текущем окне датасетами;
    \item Сохраняет текущее смещение (\texttt{offset}) получателя с помощью метода \texttt{checkpoint};
    \item Ожидаем следующий пакет, пока окно не закончилось. 
    При его появлении переходим к шагу \ref{i:gbt:map};
    \item Если окно закончилось, то весь объединённый датасет записывается в переменную \texttt{resultRdd};
    \item Полученный датасет в переменной \texttt{resultRdd} записывается в формат, установленный в файле конфигурации с помощью метода \texttt{write};
    \item Полученный датасет добавляется в базу с помощью метода \texttt{withTempView};
    \item Происходит переход к следующему временному окну;
    \item Переход к шагу \ref{i:gbt:map}.
\end{enumerate_step}

Такой алгоритм работает бесконечно, пока не будет остановлен spark-контекст, либо при возникновении ошибки.
Похожий принцип используется при разработке веб-серверов.


\subsection{Алгоритм разбора почтовых ящиков}
Алгоритм перенаправления и сортировки собранной статистики раскладывает
принятую информацию по почтовым ящикам в зависимости от источника сообщения.
Поскольку посылаемые данные могут быть слишком длинными для пересылки в
одном сообщении, они могут посылаться по частям с указанием окончания флага посылки.
Модуль межъядерного взаимодействия отдает посылки в порядке их отправления.
Но в один момент времени два ядра одновременно могут посылать информацию,
которая не может быть передана одним сообщением. В результате может возникнуть
перемешивание частей посылок разных ядер, что усложняет использование
возможности протокола веб-сокетов по дроблению пересылаемой информации на
несколько посылок.

Алгоритм реализован в функции \texttt{GlobalBenchmark\_Thread}, которая
является одной из ключевых для модуля глобального сбора сообщений. Как было сказано
ранее, данная функция принимает два параметра: \texttt{UArg a0} и \texttt{UArg a1}.
Оба параметра имеют тип \texttt{UArg}, определенный в заголовочном файле
\texttt{xdc/runtime/Types.h} и эквивалентны типу \texttt{unsigned int} языка
\texttt{C}. Значения обоих параметров не используются в работе алгоритма.

Распишем данный алгоритм по шагам:
\begin{enumerate_step}
    \item Создаем локальную переменную \texttt{receiver} типа
    \texttt{msg\_recv\_ctx\_t} для хранения контекста получателя сообщений из
    модуля межъядерного взаимодействия.
    \item Инициализируем контекст получателя сообщений вызовом функции
    \texttt{IpcMsg\_RecvInit}. Передаем в функцию идентификатор принимающей
    стороны сообщений статистики.
    \item Запоминаем код возврата из функции инициализации \texttt{IpcMsg\_RecvInit}
    в переменную \texttt{ret\_code}. Если код возврата является кодом успешной
    инициализации, переходим к шагу \ref{i:gbt:initSuccess}.
    \item Оповещаем пользователя об обнаружении ошибки инициализации приемной
    части сообщений с указанием кода возврата \texttt{ret\_code}.
    \item \label{i:gbt:initSuccess} Создаем локальную переменную \texttt{msg}
    типа \verb|sirius_msg_t*| для хранения указателя на принятое сообщение из
    модуля межъядерного взаимодействия.
    \item Принимаем сообщение в ускоренном режиме путем вызова функции
    \verb|SiriusMsg_RecvMessageNC|. В качестве аргументов указываем контекст
    принимающей стороны сообщений, адрес, куда требуется записать указатель на
    принятое сообщение, и время ожидания сообщения, эквивалентное бесконечности
    в данной функции.
    \item Запоминаем код возврата из функции инициализации
    \verb|SiriusMsg_RecvMessageNC| в переменную \texttt{ret\_code}.
    Если код возврата является кодом успешного приема сообщения, и пользователь
    включил режим отладки, переходим к шагу \ref{i:gbt:recvSuccessDbg}.
    Если код возврата является кодом успешного приема сообщения переходим
    к шагу \ref{i:gbt:recvSuccess}.
    \item Оповещаем пользователя об ошибке приема сообщения с указанием
    кода возврата \verb|ret_code|.
    \item Ждем одну секунду. Переходим к шагу \ref{i:gbt:end}.
    \item \label{i:gbt:recvSuccessDbg} Информируем пользователя об успешном приеме
    сообщения.
    \item \label{i:gbt:recvSuccess} Создаем переменную \verb|mh| типа \verb|Mailbox_Handle|, которая хранит
    идентификатор почтового ящика для пересылки полученного сообщения.
    \item Из полученного сообщения извлекаем идентификатор
    узла источника сообщений в переменную \verb|src| типа \verb|msg_node_id_t|.
    Если источником сообщения является ядро HOST, переходим к шагу
    \ref{i:gbt:idHost}. Если источником сообщения является ядро IPU1, переходим
    к шагу \ref{i:gbt:idIpu1}. Если источником сообщения является ядро DSP1,
    переходим к шагу \ref{i:gbt:idDsp1}. Если источником сообщения является
    ядро DSP2, переходим к шагу \ref{i:gbt:idDsp2}.
    \item Информируем пользователя об обнаружении неопознанного
    источника сообщений. Переходим к шагу \ref{i:gbt:freeMsg}.
    \item \label{i:gbt:idHost} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра HOST. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idIpu1} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра IPU1. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idDsp1} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра DSP1. Переходим к шагу \ref{i:gbt:mailboxSelected}.
    \item \label{i:gbt:idDsp2} Сохраняем в переменную \verb|mh| почтовый ящик
    для сообщений от ядра DSP2.
    \item \label{i:gbt:mailboxSelected} Отправляем полученное сообщение \verb|msg|
    в почтовый ящик, идентификатор которого записан в переменной \verb|mh|,
    с помощью функции \verb|Mailbox_post|. В качестве времени ожидания добавления
    сообщения используется время, равное нулю.
    \item В переменную \verb|ret_code| записываем результат выполнения функции
    \verb|Mailbox_post|. Если код возврата является кодом успешного
    отправления сообщения, переходим к шагу \ref{i:gbt:mailboxPostSuccess}.
    \item Информируем пользователя о невозможности добавления сообщения в почтовый
    ящик.
    \item \label{i:gbt:freeMsg} Удаляем из межъядерного буфера принятое сообщение.
    \item \label{i:gbt:mailboxPostSuccess} Если у пользователя выключен режим
    отладки, переходим к шагу \ref{i:gbt:end}.
    \item Информируем пользователя об окончании перенаправления сообщения.
    \item \label{i:gbt:end} Завершение итерации алгоритма. Переход к шагу
    \ref{i:gbt:initSuccess}.
\end{enumerate_step}

Таким образом, в данном подразделе был описан алгоритм работы демультиплексирования
сообщений текущего состояния ядер системы. Каждое принятое сообщение передается
в свой выделенный почтовый ящик для дальнейшего форматирования, мультиплексирования
и передачи модулю сервера веб-сокетов.

\subsection{Алгоритм разбора почтовых ящиков в модуле глобального сбора статистики}

Алгоритм перенаправления и сортировки собранной статистики перенаправляет
принятую информацию по почтовым ящикам в зависимости от ядра процессора,
которое отправило сообщение. Текущая версия позволяет разбирать до 32
очередей сообщений в одном потоке и мультиплексировать их в сообщения веб-сокетов.

Алгоритм описан в функции \verb|websock_workload_sender_task|. Поскольку
он является задачей TI-RTOS, ему требуется передать в качестве аргументов
два параметра: \verb|UArg a0| и \verb|UArg a1|. Оба параметра имеют тип
\texttt{UArg}, определенный в заголовочном файле
\texttt{xdc/runtime/Types.h}. \verb|UArg| эквивалентен типу \texttt{unsigned int}
языка \texttt{C}. Значения параметров \verb|a0| и \verb|a1| не используются
в работе алгоритма.

Рассмотрим его подробнее:
\begin{enumerate_step}
    \item \label{i:wwst:begin} Создаем локальную переменную \verb|waited_or_event|
    типа \verb|unsigned int|, которая содержит список событий, которые данная
    задача будет ждать.
    \item Указываем в списке событий для ожидания \verb|MAILBOX_HOST_EVENT_ID|,
    \verb|MAILBOX_IPU1_EVENT_ID|, \verb|MAILBOX_DSP1_EVENT_ID| и
    \verb|MAILBOX_DSP2_EVENT_ID|.
    \item Создаем дескриптор события \verb|eh| и инициализируем его
    глобальным событием \verb|MAILBOX_EVENT|, к которому привязаны почтовые
    ящики.
    \item Ожидаем какого-либо события из переменной \verb|waited_or_event|
    в дескрипторе \verb|eh| с помощью функции \verb|Event_pend|.
    \item Записываем код возврата функции \verb|Event_pend| в переменную
    \verb|event| типа \verb|unsigned int|.
    \item Входим в критическую секцию \verb|websock_handle_lock_gate| с помощью
    вызова \verb|GateMutex_enter| для обеспечения атомарности работы с
    сетевыми дескрипторами, используемыми веб-сокетами.
    \item Сохраняем код возврата из функции \verb|GateMutex_enter| в переменную
    \verb|key_gate| типа \verb|IArg| для выхода из критической секции.
    \item Проверяем наличие соединений с веб-сокет сервером. Если таковых нет,
    переходим к пункту \ref{i:wwst:freeMailBoxOnly}.
    \item Получаем дескриптор сокета для работы с клиентом. Сохраняем его в
    переменную \verb|s| типа \verb|SOCKET|.
    \item Открываем сессию для работы с файловыми дескрипторами в текущей
    задаче с помощью вызова функции \verb|fdOpenSession|.
    \item Разрешаем доступ к пользовательскому сокету \verb|s| из нескольких
    потоков одновременно.
    \item \label{i:wwst:send} Отправляем пользователю информацию, которая
    просигнализировала о своей доступности в дескрипторе события \verb|eh|
    и указана в коде возврата \verb|event|. Отправка производится с помощью
    модуля сервера веб-сокетов путем вызова \verb|websock_benchmark_send|.
    \item Получаем список текущих событий, произошедших в дескрипторе
    \verb|eh|, без ожидания их происхождения с помощью вызова функции
    \verb|Event_pend|. Сохраняем их в переменную \verb|event|.
    \item Анализируем текущие события, сохраненные в \verb|event|:
    если произошло хоть одно событие, переходим к шагу \ref{i:wwst:send}.
    \item Проверяем сокет на актуальность. Если дескриптор пользовательского
    сокета некорректен, переходим к шагу \ref{i:wwst:fdCloseDone}.
    \item Закрываем доступ к пользовательскому сокету в данном потоке
    вызовом функции \verb|fdClose|.
    \item \label{i:wwst:fdCloseDone} Закрываем сессию для работы с файловыми
    дескрипторами в текущей задаче с помощью вызова функции \verb|fdCloseSession|.
    Переходим к шагу \ref{i:wwst:leaveMutex}.
    \item \label{i:wwst:freeMailBoxOnly} Очищаем почтовые ящики с сообщениями
    без их отправки пользователю с помощью вызова \verb|websock_benchmark_send|.
    В качестве аргументов передаем туда произошедшие события заполнения почтовых
    ящиков \verb|event| и \verb|NULL| вместо указателя на дескриптор модуля
    сервера веб-сокетов.
    \item \label{i:wwst:leaveMutex} Выходим из критической секции с помощью вызова
    функции \verb|GateMutex_leave|, в которую передаем в качестве аргументов
    дескриптор критической секции \verb|websock_handle_lock_gate| и код возврата из
    функции входа в критическую секцию \verb|key_gate|.
    \item Завершение итерации алгоритма. Переход к шагу \ref{i:wwst:begin}.
\end{enumerate_step}

Таким образом, описанный выше алгоритм является задачей TI-RTOS, которая при
нормальной работе приложения никогда не должна завершить свое выполнение.
Алгоритм производит выбор способа работы с данными: производится только очистка
набора данных или производится их пересылка. Он также
позволяет избежать заторов и передавать данные полными сообщениями используя
в качестве исходящего транспорта модуль сервера веб-сокетов.

\subsection{Алгоритм пересылки сообщений из почтового ящика в модуль сервера
веб-сокетов}

При разборе почтовых ящиков сначала производится выбор ящика, который будет
источником сообщений в данный момент времени, а затем -- пересылка данных
по требуемому транспорту. Первая часть подробно описана в предыдущем алгоритме.
Вторая относится к текущему.

Сам алгоритм описан в функции \verb|websock_benchmark_send_mailbox|, которая
принимает два аргумента: \verb|Mailbox_Handle mh|, который и является дескриптором
почтового ящика, и \verb|WebSocketServer* wsserver|, который является дескриптором
сервера веб-сокетов. Рассмотрим алгоритм подробнее:
\begin{enumerate_step}
    \item Создаем локальную переменную \verb|is_last| типа \verb|bool|, которая
    хранит, является ли последнее принятое сообщение финальным
    в последовательности. Значение \verb|true| соответствует финальному сообщению.
    Значение \verb|false| -- не финальному.
    \item Инициализируем \verb|is_last| в состояние финального сообщения.
    \item \label{i:wbsm:mainLoopStart} Создаем переменную \verb|ipc_msg| типа
    \verb|sirius_msg_t*|, в которую будет записано сообщение из выбранной
    очереди.
    \item Создаем переменную \verb|timeout| типа \verb|uint32_t|, которая
    определяет время ожидания сообщения в почтовом ящике. Если \verb|is_last|
    соответствует финальному сообщению, то переменная примет значение нуля,
    иначе -- времени, определенному пользователем в переменной
    \verb|MAILBOX_WAIT_NEXT_PART_MS|.
    \item Принимаем сообщение из почтового ящика \verb|mh| с помощью вызова функции
    \verb|Mailbox_pend| с максимальным временем ожидания \verb|timeout|.
    \item Сохраняем результат работы функции \verb|Mailbox_pend| в переменную
    \verb|is_good|. Если результат работы не совпадает с успешным принятием данных,
    переходим к шагу \ref{i:wbsm:exitCheck}.
    \item Создаем локальную переменную \verb|msg_hdr| типа \verb|benchmark_msg_t*|,
    который содержит указатель на заголовок в принятом сообщении.
    \item Создаем локальную переменную \verb|msg_payload| типа \verb|uint8_t*|,
    который содержит указатель на данные в принятом сообщении из модуля межъядерного
    взаимодействия.
    \item Обновляем значение локальной переменной \verb|is_last| в соответствии
    с аналогичным полем в \verb|msg_hdr|.
    Если пользователь не включал отладочный режим, переходим к шагу
    \ref{i:wbsm:sendMsg}.
    \item Выводим заголовок принятого сообщения в отладочную консоль.
    \item Выводим тело принятого сообщения в отладочную консоль.
    \item \label{i:wbsm:sendMsg} Если не определен дескриптор сервера веб-сокетов,
    переходим к шагу \ref{i:wbsm:freeMsg}.
    \item Создаем буфер для форматирования сообщения \verb|msg_format|.
    \item Форматируем принятые из почтового ящика полезные данные \verb|msg_payload|
    с помощью вызова функции \verb|websock_benchmark_format_message|. Передаем
    в нее буфер \verb|msg_format|.
    \item Сохраняем результат работы функции \verb|websock_benchmark_format_message|
    в переменную \verb|msg_format_size| типа \verb|uint16_t|,
    которая содержит размер принятых полезных данных в сообщении. Если
    \verb|msg_format_size| равно нулю, переходим к шагу \ref{i:wbsm:freeMsg}.
    \item Отправляем данные с помощью модуля сервера веб-сокетов с помощью
    вызова функции \verb|websocketServer_sendData|. В качестве аргументов
    передаем \verb|msg_format|, \verb|msg_format_size| и \verb|is_last|.
    \item \label{i:wbsm:freeMsg} Освобождаем память в межъядерном буфере с
    помощью вызова функции \verb|IpcMsg_FreeMessageNC|. В качестве аргумента
    передаем принятый из почтового ящика указатель \verb|ipc_msg|. Переходим
    к шагу \ref{i:wbsm:mainLoopStart}.
    \item \label{i:wbsm:exitCheck} Если флаг \verb|is_last| находится в состоянии
    последнего сообщения, переходим к шагу \ref{i:wbsm:end}.
    \item Вывод сообщения о ненахождении последнего сообщения за отведенное время.
    Если не определен дескриптор сервера веб-сокетов, переходим к шагу
    \ref{i:wbsm:end}.
    \item Отправляем данные с помощью модуля сервера веб-сокетов с помощью
    вызова функции \verb|websocketServer_sendData|. В качестве аргументов
    передаем \verb|NULL| вместо указателя на буфер, нулевую длину и
    флаг принудительного окончания сообщения.
    \item \label{i:wbsm:end} Завершение алгоритма.
\end{enumerate_step}

Таким образом, в данном подразделе описан алгоритм очистки почтового ящика по
целым сообщениям, форматирования их и передачи в модуль сервера веб-сокетов.
Если конец сообщения не был получен за отведенное время,
сообщение будет принудительно окончено, а пользователю выдано соответствующее
уведомление.

В данном разделе были описаны ключевые алгоритмы работы системы. Они позволяют
эффективно проводить требуемые операции и соответствовать требованиям операционной
системы реального времени.